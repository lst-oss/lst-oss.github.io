

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="l1s00t">
  <meta name="keywords" content="">
  
    <meta name="description" content="AFL源码分析(四)afl-fuzz.cmain函数主循环123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960while (1) &amp;#123;   u8 skipped_fuzz;   cull_queue();       &#x2F;&#x2F;">
<meta property="og:type" content="article">
<meta property="og:title" content="AFL源码分析(四)">
<meta property="og:url" content="http://example.com/2023/10/04/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9B%9B/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="AFL源码分析(四)afl-fuzz.cmain函数主循环123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960while (1) &amp;#123;   u8 skipped_fuzz;   cull_queue();       &#x2F;&#x2F;">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-10-04T07:45:04.000Z">
<meta property="article:modified_time" content="2023-10-06T15:21:16.077Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="fuzz">
<meta property="article:tag" content="afl">
<meta name="twitter:card" content="summary_large_image">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>AFL源码分析(四) - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>l1s00t</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="AFL源码分析(四)"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-10-04 15:45" pubdate>
          2023年10月4日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          56k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          233 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">AFL源码分析(四)</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2023年10月6日 晚上
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <h1 id="AFL源码分析-四"><a href="#AFL源码分析-四" class="headerlink" title="AFL源码分析(四)"></a>AFL源码分析(四)</h1><h2 id="afl-fuzz-c"><a href="#afl-fuzz-c" class="headerlink" title="afl-fuzz.c"></a>afl-fuzz.c</h2><h3 id="main函数主循环"><a href="#main函数主循环" class="headerlink" title="main函数主循环"></a>main函数主循环</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br><br>   u8 skipped_fuzz;<br><br>   cull_queue();       <span class="hljs-comment">// 精简队列</span><br><br>   <span class="hljs-keyword">if</span> (!queue_cur) &#123;   <span class="hljs-comment">// 如果queue_cur为空，代表所有queue都被执行完一轮</span><br><br>     queue_cycle++;    <span class="hljs-comment">// 所有queue被完整执行了多少轮</span><br>     current_entry     = <span class="hljs-number">0</span>;<br>     cur_skipped_paths = <span class="hljs-number">0</span>;<br>     queue_cur         = <span class="hljs-built_in">queue</span>;        <span class="hljs-comment">// 开始新一轮fuzz</span><br><br>     <span class="hljs-keyword">while</span> (seek_to) &#123;         <span class="hljs-comment">// resume fuzz</span><br>       current_entry++;<br>       seek_to--;<br>       queue_cur = queue_cur-&gt;next;    <span class="hljs-comment">// 从seek_to指定的queue项开始执行</span><br>     &#125;<br><br>     show_stats();     <span class="hljs-comment">// 显示stat信息</span><br><br>     <span class="hljs-keyword">if</span> (not_on_tty) &#123;<br>       ACTF(<span class="hljs-string">&quot;Entering queue cycle %llu.&quot;</span>, queue_cycle);<br>       fflush(<span class="hljs-built_in">stdout</span>);<br>     &#125;<br><br>     <span class="hljs-comment">/* If we had a full queue cycle with no new finds, try</span><br><span class="hljs-comment">        recombination strategies next. */</span><br><br>     <span class="hljs-keyword">if</span> (queued_paths == prev_queued) &#123;        <span class="hljs-comment">// 代表在完整的一轮执行里都没有发现任何一个新的case</span><br><br>       <span class="hljs-keyword">if</span> (use_splicing) cycles_wo_finds++; <span class="hljs-keyword">else</span> use_splicing = <span class="hljs-number">1</span>;     <span class="hljs-comment">// 若use_splicing为1(通过-d参数设置)，代表接下来要通过splice重组queue里的case</span><br><br>     &#125; <span class="hljs-keyword">else</span> cycles_wo_finds = <span class="hljs-number">0</span>;<br><br>     prev_queued = queued_paths;       <span class="hljs-comment">// 设置prev_queued为当前发现的queued_paths</span><br><br>     <span class="hljs-keyword">if</span> (sync_id &amp;&amp; queue_cycle == <span class="hljs-number">1</span> &amp;&amp; getenv(<span class="hljs-string">&quot;AFL_IMPORT_FIRST&quot;</span>))    <span class="hljs-comment">// 若sync_id不为空，且queue_cycle等于1</span><br>       sync_fuzzers(use_argv);         <span class="hljs-comment">// 读取其他sync文件夹下的queue，保存到主queue中</span><br><br>   &#125;<br><br>   skipped_fuzz = fuzz_one(use_argv);  <span class="hljs-comment">// 对queue_cur进行测试，若不执行返回1，否则返回0</span><br><br>   <span class="hljs-keyword">if</span> (!stop_soon &amp;&amp; sync_id &amp;&amp; !skipped_fuzz) &#123;       <span class="hljs-comment">// 若stop_soon为空，sync_id不为空，skipped_fuzz为空</span><br>     <br>     <span class="hljs-keyword">if</span> (!(sync_interval_cnt++ % SYNC_INTERVAL))       <span class="hljs-comment">// 同步sync文件夹下的queue</span><br>       sync_fuzzers(use_argv);<br><br>   &#125;<br><br>   <span class="hljs-keyword">if</span> (!stop_soon &amp;&amp; exit_1) stop_soon = <span class="hljs-number">2</span>;    <span class="hljs-comment">// 若stop_soon为空，exit_1不为空，设置stop_soon为2</span><br><br>   <span class="hljs-keyword">if</span> (stop_soon) <span class="hljs-keyword">break</span>;       <span class="hljs-comment">// 跳出死循环唯一途径</span><br><br>   queue_cur = queue_cur-&gt;next;        <span class="hljs-comment">// 设置queue_cur为queue_cur的next</span><br>   current_entry++;<br><br> &#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="fuzz-one"><a href="#fuzz-one" class="headerlink" title="fuzz_one"></a>fuzz_one</h3><p>fuzz_one作为fuzz的核心函数，主要有以下几个阶段：</p>
<ul>
<li>前期准备阶段</li>
<li>CALIBRATION阶段</li>
<li>TRIMMING阶段</li>
<li>PERFORMANCE SCORE阶段</li>
<li>SIMPLE BITFLIP (+dictionary construction) 简单位翻转</li>
<li>ARITHMETIC INC&#x2F;DEC 算术加减</li>
<li>INTERESTING VALUES</li>
<li>DICTIONARY STUFF</li>
<li>RANDOM HAVOC</li>
<li>SPLICING</li>
<li>后期收尾阶段</li>
</ul>
<h4 id="前期准备阶段"><a href="#前期准备阶段" class="headerlink" title="前期准备阶段"></a>前期准备阶段</h4><p>根据概率判断是否开启fuzz，建立文件映射，建立输出缓冲区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Take the current entry from the queue, fuzz it for a while. This</span><br><span class="hljs-comment">   function is a tad too long... returns 0 if fuzzed successfully, 1 if</span><br><span class="hljs-comment">   skipped or bailed out. */</span><br><br><span class="hljs-type">static</span> u8 <span class="hljs-title function_">fuzz_one</span><span class="hljs-params">(<span class="hljs-type">char</span>** argv)</span> &#123;<br><br>  s32 len, fd, temp_len, i, j;<br>  u8  *in_buf, *out_buf, *orig_in, *ex_tmp, *eff_map = <span class="hljs-number">0</span>;<br>  u64 havoc_queued,  orig_hit_cnt, new_hit_cnt;<br>  u32 splice_cycle = <span class="hljs-number">0</span>, perf_score = <span class="hljs-number">100</span>, orig_perf, prev_cksum, eff_cnt = <span class="hljs-number">1</span>;<br><br>  u8  ret_val = <span class="hljs-number">1</span>, doing_det = <span class="hljs-number">0</span>;<br><br>  u8  a_collect[MAX_AUTO_EXTRA];<br>  u32 a_len = <span class="hljs-number">0</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> IGNORE_FINDS</span><br><br>  <span class="hljs-comment">/* In IGNORE_FINDS mode, skip any entries that weren&#x27;t in the</span><br><span class="hljs-comment">     initial data set. */</span><br>  <span class="hljs-comment">// 在IGNORE_FINDS模式下，跳过所有不在初始数据集中的条目。</span><br>  <br>  <span class="hljs-keyword">if</span> (queue_cur-&gt;depth &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><br>  <span class="hljs-keyword">if</span> (pending_favored) &#123;        <span class="hljs-comment">// pending_favored不为空的条件下，若was_fuzzed不为空，或者favored为空，则99%概率直接返回1</span><br><br>    <span class="hljs-comment">/* If we have any favored, non-fuzzed new arrivals in the queue,</span><br><span class="hljs-comment">       possibly skip to them at the expense of already-fuzzed or non-favored</span><br><span class="hljs-comment">       cases. */</span><br><br>    <span class="hljs-keyword">if</span> ((queue_cur-&gt;was_fuzzed || !queue_cur-&gt;favored) &amp;&amp;<br>        UR(<span class="hljs-number">100</span>) &lt; SKIP_TO_NEW_PROB) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;   <span class="hljs-comment">// 99%</span><br><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!dumb_mode &amp;&amp; !queue_cur-&gt;favored &amp;&amp; queued_paths &gt; <span class="hljs-number">10</span>) &#123;  <span class="hljs-comment">// 若不是简易模式，favored为空，且queued_paths大于10</span><br><br>    <span class="hljs-comment">/* Otherwise, still possibly skip non-favored cases, albeit less often.</span><br><span class="hljs-comment">       The odds of skipping stuff are higher for already-fuzzed inputs and</span><br><span class="hljs-comment">       lower for never-fuzzed entries. */</span><br><br>    <span class="hljs-keyword">if</span> (queue_cycle &gt; <span class="hljs-number">1</span> &amp;&amp; !queue_cur-&gt;was_fuzzed) &#123;    <span class="hljs-comment">// 若queue_cycle大于1，且queue_cur没有被fuzz过，75%概率直接返回1</span><br><br>      <span class="hljs-keyword">if</span> (UR(<span class="hljs-number">100</span>) &lt; SKIP_NFAV_NEW_PROB) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;       <span class="hljs-comment">// 75%</span><br><br>    &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 否则queue_cur被fuzz过，95%概率返回1</span><br><br>      <span class="hljs-keyword">if</span> (UR(<span class="hljs-number">100</span>) &lt; SKIP_NFAV_OLD_PROB) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;       <span class="hljs-comment">// 95%</span><br><br>    &#125;<br><br>  &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* ^IGNORE_FINDS */</span></span><br><br>  <span class="hljs-keyword">if</span> (not_on_tty) &#123;     <span class="hljs-comment">// 若不是在tty终端</span><br>    ACTF(<span class="hljs-string">&quot;Fuzzing test case #%u (%u total, %llu uniq crashes found)...&quot;</span>,<br>         current_entry, queued_paths, unique_crashes);  <span class="hljs-comment">// 打印路径，crash信息</span><br>    fflush(<span class="hljs-built_in">stdout</span>);     <span class="hljs-comment">// 刷新stdout缓冲区</span><br>  &#125;<br><br>  <span class="hljs-comment">/* Map the test case into memory. */</span><br><br>  fd = open(queue_cur-&gt;fname, O_RDONLY);        <span class="hljs-comment">// 以只读模式打开queue_cur-&gt;fname，即打开测试文件</span><br><br>  <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) PFATAL(<span class="hljs-string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, queue_cur-&gt;fname);<br><br>  len = queue_cur-&gt;len;<br><br>  orig_in = in_buf = mmap(<span class="hljs-number">0</span>, len, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 建立可读可写的文件映射</span><br><br>  <span class="hljs-keyword">if</span> (orig_in == MAP_FAILED) PFATAL(<span class="hljs-string">&quot;Unable to mmap &#x27;%s&#x27;&quot;</span>, queue_cur-&gt;fname);<br><br>  close(fd);    <span class="hljs-comment">// 关闭queue_cur-&gt;fname</span><br><br>  <span class="hljs-comment">/* We could mmap() out_buf as MAP_PRIVATE, but we end up clobbering every</span><br><span class="hljs-comment">     single byte anyway, so it wouldn&#x27;t give us any performance or memory usage</span><br><span class="hljs-comment">     benefits. */</span><br>  <br>  out_buf = ck_alloc_nozero(len);       <span class="hljs-comment">// 建立输出缓冲区</span><br><br>  subseq_tmouts = <span class="hljs-number">0</span>;<br><br>  cur_depth = queue_cur-&gt;depth;<br></code></pre></td></tr></table></figure>



<h4 id="CALIBRATION"><a href="#CALIBRATION" class="headerlink" title="CALIBRATION"></a>CALIBRATION</h4><p>若评估失败，且评估次数小于3次，再次评估测试用例。根据评估用例判断是否继续进行fuzz。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (queue_cur-&gt;cal_failed) &#123;  <span class="hljs-comment">// case存在评估错误</span><br><br>    u8 res = FAULT_TMOUT;<br><br>    <span class="hljs-keyword">if</span> (queue_cur-&gt;cal_failed &lt; CAL_CHANCES) &#123;  <span class="hljs-comment">// 小于3次，再次校准</span><br><br>      <span class="hljs-comment">/* Reset exec_cksum to tell calibrate_case to re-execute the testcase</span><br><span class="hljs-comment">         avoiding the usage of an invalid trace_bits.</span><br><span class="hljs-comment">         For more info: https://github.com/AFLplusplus/AFLplusplus/pull/425 */</span><br><br>      queue_cur-&gt;exec_cksum = <span class="hljs-number">0</span>;<br><br>      res = calibrate_case(argv, queue_cur, in_buf, queue_cycle - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);        <span class="hljs-comment">// 再次评估测试用例</span><br><br>      <span class="hljs-keyword">if</span> (res == FAULT_ERROR)   <span class="hljs-comment">// 若res为FAULT_ERROR，报错并推出</span><br>        FATAL(<span class="hljs-string">&quot;Unable to execute target application&quot;</span>);<br><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (stop_soon || res != crash_mode) &#123;       <span class="hljs-comment">// 若stop_soon不为空，或者res不等于crash_mode</span><br>      cur_skipped_paths++;      <span class="hljs-comment">// cur_skipped_paths + 1</span><br>      <span class="hljs-keyword">goto</span> abandon_entry;       <span class="hljs-comment">// 跳转到abandon_entry</span><br>    &#125;<br><br>  &#125;<br></code></pre></td></tr></table></figure>



<h4 id="TRIMMING"><a href="#TRIMMING" class="headerlink" title="TRIMMING"></a>TRIMMING</h4><p>对queue_cur进行剪枝，初始化out_buf。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (!dumb_mode &amp;&amp; !queue_cur-&gt;trim_done) &#123;    <span class="hljs-comment">// 若不是简易模式，且queue_cur还未被trim过</span><br><br>   u8 res = trim_case(argv, queue_cur, in_buf);        <span class="hljs-comment">// 对queue_cur进行trim</span><br><br>   <span class="hljs-keyword">if</span> (res == FAULT_ERROR)      <span class="hljs-comment">// 若res为FAULT_ERROR，报错并推出</span><br>     FATAL(<span class="hljs-string">&quot;Unable to execute target application&quot;</span>);<br><br>   <span class="hljs-keyword">if</span> (stop_soon) &#123;    <span class="hljs-comment">// 若stop_soon不为空</span><br>     cur_skipped_paths++;<br>     <span class="hljs-keyword">goto</span> abandon_entry;<br>   &#125;<br><br>   <span class="hljs-comment">/* Don&#x27;t retry trimming, even if it failed. */</span><br><br>   queue_cur-&gt;trim_done = <span class="hljs-number">1</span>;   <span class="hljs-comment">// 设置queue_cur的trim标志</span><br><br>   <span class="hljs-keyword">if</span> (len != queue_cur-&gt;len) len = queue_cur-&gt;len;    <span class="hljs-comment">// trim后更新queue长度</span><br><br> &#125;<br><br> <span class="hljs-built_in">memcpy</span>(out_buf, in_buf, len); <span class="hljs-comment">// 将in_buf长度为len的内容拷贝到out_buf</span><br></code></pre></td></tr></table></figure>



<h4 id="PERFORMANCE-SCORE"><a href="#PERFORMANCE-SCORE" class="headerlink" title="PERFORMANCE SCORE"></a>PERFORMANCE SCORE</h4><p>计算测试用例得分，进行简单的deterministic。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">orig_perf = perf_score = calculate_score(queue_cur);  <span class="hljs-comment">// 计算queue_cur的得分</span><br><br>  <span class="hljs-comment">/* Skip right away if -d is given, if we have done deterministic fuzzing on</span><br><span class="hljs-comment">     this entry ourselves (was_fuzzed), or if it has gone through deterministic</span><br><span class="hljs-comment">     testing in earlier, resumed runs (passed_det). */</span><br><br>  <span class="hljs-keyword">if</span> (skip_deterministic || queue_cur-&gt;was_fuzzed || queue_cur-&gt;passed_det)     <br>    <span class="hljs-keyword">goto</span> havoc_stage;   <span class="hljs-comment">// 若跳过deterministic，或者已经被fuzz过，或者已经经过deterministic了，跳转到havoc_stage</span><br><br>  <span class="hljs-comment">/* Skip deterministic fuzzing if exec path checksum puts this out of scope</span><br><span class="hljs-comment">     for this master instance. */</span><br>  <span class="hljs-comment">// 跳过从fuzz的确定性fuzz</span><br>  <span class="hljs-keyword">if</span> (master_max &amp;&amp; (queue_cur-&gt;exec_cksum % master_max) != master_id - <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">goto</span> havoc_stage;<br><br>  doing_det = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>



<h4 id="SIMPLE-BITFLIP-dictionary-construction"><a href="#SIMPLE-BITFLIP-dictionary-construction" class="headerlink" title="SIMPLE BITFLIP (+dictionary construction)"></a>SIMPLE BITFLIP (+dictionary construction)</h4><p>对out_buf做简单的位翻转。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> FLIP_BIT(_ar, _b) do &#123; \</span><br><span class="hljs-meta">    u8* _arf = (u8*)(_ar); \</span><br><span class="hljs-meta">    u32 _bf = (_b); \</span><br><span class="hljs-meta">    _arf[(_bf) &gt;&gt; 3] ^= (128 &gt;&gt; ((_bf) &amp; 7)); \</span><br><span class="hljs-meta">  &#125; while (0)   <span class="hljs-comment">// 对每一个byte进行逐位取反操作</span></span><br><br>  <span class="hljs-comment">/* Single walking bit. */</span><br>  <br>  stage_short = <span class="hljs-string">&quot;flip1&quot;</span>;<br>  stage_max   = len &lt;&lt; <span class="hljs-number">3</span>;<br>  stage_name  = <span class="hljs-string">&quot;bitflip 1/1&quot;</span>;<br><br>  stage_val_type = STAGE_VAL_NONE;<br><br>  orig_hit_cnt = queued_paths + unique_crashes;<br><br>  prev_cksum = queue_cur-&gt;exec_cksum;<br><br>  <span class="hljs-keyword">for</span> (stage_cur = <span class="hljs-number">0</span>; stage_cur &lt; stage_max; stage_cur++) &#123;     <span class="hljs-comment">// 循环stage_max轮次</span><br><br>    stage_cur_byte = stage_cur &gt;&gt; <span class="hljs-number">3</span>;<br>  <br>    FLIP_BIT(out_buf, stage_cur);       <span class="hljs-comment">// out_buf按位取反</span><br><br>    <span class="hljs-keyword">if</span> (common_fuzz_stuff(argv, out_buf, len))  <span class="hljs-comment">// 调用common_fuzz_stuff进行fuzz，保存interesting种子</span><br>        <span class="hljs-keyword">goto</span> abandon_entry;<br><br>    FLIP_BIT(out_buf, stage_cur);       <span class="hljs-comment">// 翻转回来</span><br><br>    <span class="hljs-comment">/* While flipping the least significant bit in every byte, pull of an extra</span><br><span class="hljs-comment">       trick to detect possible syntax tokens. In essence, the idea is that if</span><br><span class="hljs-comment">       you have a binary blob like this:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">       xxxxxxxxIHDRxxxxxxxx</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">       ...and changing the leading and trailing bytes causes variable or no</span><br><span class="hljs-comment">       changes in program flow, but touching any character in the &quot;IHDR&quot; string</span><br><span class="hljs-comment">       always produces the same, distinctive path, it&#x27;s highly likely that</span><br><span class="hljs-comment">       &quot;IHDR&quot; is an atomically-checked magic value of special significance to</span><br><span class="hljs-comment">       the fuzzed format.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">       We do this here, rather than as a separate stage, because it&#x27;s a nice</span><br><span class="hljs-comment">       way to keep the operation approximately &quot;free&quot; (i.e., no extra execs).</span><br><span class="hljs-comment">       </span><br><span class="hljs-comment">       Empirically, performing the check when flipping the least significant bit</span><br><span class="hljs-comment">       is advantageous, compared to doing it at the time of more disruptive</span><br><span class="hljs-comment">       changes, where the program flow may be affected in more violent ways.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">       The caveat is that we won&#x27;t generate dictionaries in the -d mode or -S</span><br><span class="hljs-comment">       mode - but that&#x27;s probably a fair trade-off.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">       This won&#x27;t work particularly well with paths that exhibit variable</span><br><span class="hljs-comment">       behavior, but fails gracefully, so we&#x27;ll carry out the checks anyway.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">      */</span><br><br>    <span class="hljs-keyword">if</span> (!dumb_mode &amp;&amp; (stage_cur &amp; <span class="hljs-number">7</span>) == <span class="hljs-number">7</span>) &#123;   <span class="hljs-comment">// stage_cur = 7(111), 15(1111), 23(10111), ...</span><br><br>      u32 cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);     <span class="hljs-comment">// 计算trace_bits校验和</span><br>      <br>      <span class="hljs-comment">// 当循环到stage_max - 1次时，比较ck_sum与prev_cksum，即比较当前路径与上一次路径是否变化</span><br>      <br>      <span class="hljs-keyword">if</span> (stage_cur == stage_max - <span class="hljs-number">1</span> &amp;&amp; cksum == prev_cksum) &#123;  <span class="hljs-comment">// 若路径相同</span><br>        <br>        <span class="hljs-comment">/* If at end of file and we are still collecting a string, grab the</span><br><span class="hljs-comment">           final character and force output. */</span><br><br>        <span class="hljs-keyword">if</span> (a_len &lt; MAX_AUTO_EXTRA) a_collect[a_len] = out_buf[stage_cur &gt;&gt; <span class="hljs-number">3</span>]; <span class="hljs-comment">// 若a_len &lt; 32，添加当前字符到a_collec</span><br>        a_len++;<br><br>        <span class="hljs-keyword">if</span> (a_len &gt;= MIN_AUTO_EXTRA &amp;&amp; a_len &lt;= MAX_AUTO_EXTRA) <span class="hljs-comment">// 若a_len长度为合法token长度</span><br>          maybe_add_auto(a_collect, a_len);     <span class="hljs-comment">// 将累计的a_collect数组内容添加到a_extras数组中</span><br><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cksum != prev_cksum) &#123; <span class="hljs-comment">// 若路径不同，即发现了新的token</span><br><br>        <span class="hljs-comment">/* Otherwise, if the checksum has changed, see if we have something</span><br><span class="hljs-comment">           worthwhile queued up, and collect that if the answer is yes. */</span><br><br>        <span class="hljs-keyword">if</span> (a_len &gt;= MIN_AUTO_EXTRA &amp;&amp; a_len &lt;= MAX_AUTO_EXTRA)<br>          maybe_add_auto(a_collect, a_len);     <span class="hljs-comment">// 将a_collect添加到a_extras数组中</span><br><br>        a_len = <span class="hljs-number">0</span>;<br>        prev_cksum = cksum;     <span class="hljs-comment">// 设置prev_cksum为当前cksum</span><br><br>      &#125;<br><br>      <span class="hljs-comment">/* Continue collecting string, but only if the bit flip actually made</span><br><span class="hljs-comment">         any difference - we don&#x27;t want no-op tokens. */</span><br><br>      <span class="hljs-keyword">if</span> (cksum != queue_cur-&gt;exec_cksum) &#123;     <span class="hljs-comment">// 若路径不相同，添加当前字节到a_collect中</span><br><br>        <span class="hljs-keyword">if</span> (a_len &lt; MAX_AUTO_EXTRA) a_collect[a_len] = out_buf[stage_cur &gt;&gt; <span class="hljs-number">3</span>];        <br>        a_len++;<br><br>      &#125;<br><br>    &#125;<br><br>  &#125;<br><br>  new_hit_cnt = queued_paths + unique_crashes;<br><br>  stage_finds[STAGE_FLIP1]  += new_hit_cnt - orig_hit_cnt;      <span class="hljs-comment">// stage_finds[STAGE_FLIP1]的值加上在整个FLIP_BIT中新发现的路径和Crash总和</span><br>  stage_cycles[STAGE_FLIP1] += stage_max;       <span class="hljs-comment">// stage_cycles[STAGE_FLIP1]的值加上在整个FLIP_BIT中执行的target次数stage_max</span><br><br>  <span class="hljs-comment">/* Two walking bits. */</span>       <br><br>  stage_name  = <span class="hljs-string">&quot;bitflip 2/1&quot;</span>;  <span class="hljs-comment">// bitflip 2/1，与上述bitflip 1/1过程一样，只是连续翻转2位</span><br>  stage_short = <span class="hljs-string">&quot;flip2&quot;</span>;<br>  stage_max   = (len &lt;&lt; <span class="hljs-number">3</span>) - <span class="hljs-number">1</span>;<br><br>  orig_hit_cnt = new_hit_cnt;<br><br>  <span class="hljs-keyword">for</span> (stage_cur = <span class="hljs-number">0</span>; stage_cur &lt; stage_max; stage_cur++) &#123;<br><br>    stage_cur_byte = stage_cur &gt;&gt; <span class="hljs-number">3</span>;<br><br>    FLIP_BIT(out_buf, stage_cur);<br>    FLIP_BIT(out_buf, stage_cur + <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="hljs-keyword">goto</span> abandon_entry;<br><br>    FLIP_BIT(out_buf, stage_cur);<br>    FLIP_BIT(out_buf, stage_cur + <span class="hljs-number">1</span>);<br><br>  &#125;<br><br>  new_hit_cnt = queued_paths + unique_crashes;<br><br>  stage_finds[STAGE_FLIP2]  += new_hit_cnt - orig_hit_cnt;<br>  stage_cycles[STAGE_FLIP2] += stage_max;<br><br>  <span class="hljs-comment">/* Four walking bits. */</span>      <br><br>  stage_name  = <span class="hljs-string">&quot;bitflip 4/1&quot;</span>;  <span class="hljs-comment">// bitflip 4/1，与上述bitflip 1/1过程一样，只是连续翻转4位</span><br>  stage_short = <span class="hljs-string">&quot;flip4&quot;</span>;<br>  stage_max   = (len &lt;&lt; <span class="hljs-number">3</span>) - <span class="hljs-number">3</span>;<br><br>  orig_hit_cnt = new_hit_cnt;<br><br>  <span class="hljs-keyword">for</span> (stage_cur = <span class="hljs-number">0</span>; stage_cur &lt; stage_max; stage_cur++) &#123;<br><br>    stage_cur_byte = stage_cur &gt;&gt; <span class="hljs-number">3</span>;<br><br>    FLIP_BIT(out_buf, stage_cur);<br>    FLIP_BIT(out_buf, stage_cur + <span class="hljs-number">1</span>);<br>    FLIP_BIT(out_buf, stage_cur + <span class="hljs-number">2</span>);<br>    FLIP_BIT(out_buf, stage_cur + <span class="hljs-number">3</span>);<br><br>    <span class="hljs-keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="hljs-keyword">goto</span> abandon_entry;<br><br>    FLIP_BIT(out_buf, stage_cur);<br>    FLIP_BIT(out_buf, stage_cur + <span class="hljs-number">1</span>);<br>    FLIP_BIT(out_buf, stage_cur + <span class="hljs-number">2</span>);<br>    FLIP_BIT(out_buf, stage_cur + <span class="hljs-number">3</span>);<br><br>  &#125;<br><br>  new_hit_cnt = queued_paths + unique_crashes;<br><br>  stage_finds[STAGE_FLIP4]  += new_hit_cnt - orig_hit_cnt;<br>  stage_cycles[STAGE_FLIP4] += stage_max;<br><br>  <span class="hljs-comment">/* Effector map setup. These macros calculate:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     EFF_APOS      - position of a particular file offset in the map.</span><br><span class="hljs-comment">     EFF_ALEN      - length of a map with a particular number of bytes.</span><br><span class="hljs-comment">     EFF_SPAN_ALEN - map span for a sequence of bytes.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EFF_APOS(_p)          ((_p) &gt;&gt; EFF_MAP_SCALE2)  <span class="hljs-comment">// p &gt;&gt; 3</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EFF_REM(_x)           ((_x) &amp; ((1 &lt;&lt; EFF_MAP_SCALE2) - 1))      <span class="hljs-comment">// x &amp; 7</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EFF_ALEN(_l)          (EFF_APOS(_l) + !!EFF_REM(_l))    <span class="hljs-comment">// (l &gt;&gt; 3) + !! (l &amp; 7)</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EFF_SPAN_ALEN(_p, _l) (EFF_APOS((_p) + (_l) - 1) - EFF_APOS(_p) + 1)    <span class="hljs-comment">// (p + l - 1) &gt;&gt; 3 - (p &gt;&gt; 3) + 1</span></span><br><br>  <span class="hljs-comment">/* Initialize effector map for the next step (see comments below). Always</span><br><span class="hljs-comment">     flag first and last byte as doing something. */</span><br><br>  eff_map    = ck_alloc(EFF_ALEN(len)); <span class="hljs-comment">// 为eff_map分配空间，对每个byte进行翻转时，如果其造成执行路径与原始路径不一致，</span><br>                                        <span class="hljs-comment">// 就将该byte在effector map中标记为1，即“有效”的，否则标记为0，即“无效”的。</span><br>  eff_map[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">if</span> (EFF_APOS(len - <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// len &gt; 9</span><br>    eff_map[EFF_APOS(len - <span class="hljs-number">1</span>)] = <span class="hljs-number">1</span>;<br>    eff_cnt++;<br>  &#125;<br><br>  <span class="hljs-comment">/* Walking byte. */</span><br><br>  stage_name  = <span class="hljs-string">&quot;bitflip 8/8&quot;</span>;  <span class="hljs-comment">// bitflip 8/8与上述位翻转策略不同，以字节为单位进行翻转</span><br>  stage_short = <span class="hljs-string">&quot;flip8&quot;</span>;<br>  stage_max   = len;<br><br>  orig_hit_cnt = new_hit_cnt;<br><br>  <span class="hljs-keyword">for</span> (stage_cur = <span class="hljs-number">0</span>; stage_cur &lt; stage_max; stage_cur++) &#123;<br><br>    stage_cur_byte = stage_cur;<br><br>    out_buf[stage_cur] ^= <span class="hljs-number">0xFF</span>; <span class="hljs-comment">// 翻转策略，与0xff进行异或</span><br><br>    <span class="hljs-keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="hljs-keyword">goto</span> abandon_entry;<br><br>    <span class="hljs-comment">/* We also use this stage to pull off a simple trick: we identify</span><br><span class="hljs-comment">       bytes that seem to have no effect on the current execution path</span><br><span class="hljs-comment">       even when fully flipped - and we skip them during more expensive</span><br><span class="hljs-comment">       deterministic stages, such as arithmetics or known ints. */</span><br>    <br>    <span class="hljs-comment">/* 识别那些即使完全翻转也不会对当前执行路径产生影响的字节，并在更昂贵的</span><br><span class="hljs-comment">    确定性阶段跳过它们，例如算术或已知的整数。 */</span><br><br>    <span class="hljs-keyword">if</span> (!eff_map[EFF_APOS(stage_cur)]) &#123;        <span class="hljs-comment">// eff_map[stage_cur &gt;&gt; 3] == 0</span><br><br>      u32 cksum;<br><br>      <span class="hljs-comment">/* If in dumb mode or if the file is very short, just flag everything</span><br><span class="hljs-comment">         without wasting time on checksums. */</span><br><br>      <span class="hljs-keyword">if</span> (!dumb_mode &amp;&amp; len &gt;= EFF_MIN_LEN)     <span class="hljs-comment">// 如果不是dumb_mode且len &gt;= 128，计算校验和</span><br>        cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);<br>      <span class="hljs-keyword">else</span>      <span class="hljs-comment">// 否则，校验和等于exec_cksum按位取反</span><br>        cksum = ~queue_cur-&gt;exec_cksum;<br><br>      <span class="hljs-keyword">if</span> (cksum != queue_cur-&gt;exec_cksum) &#123;     <span class="hljs-comment">// 若发现了新的路径</span><br>        eff_map[EFF_APOS(stage_cur)] = <span class="hljs-number">1</span>;       <span class="hljs-comment">// 设置eff_map[stage_cur &gt;&gt; 3] = 1</span><br>        eff_cnt++;      <span class="hljs-comment">// eff_cnt + 1</span><br>      &#125;<br><br>    &#125;<br><br>    out_buf[stage_cur] ^= <span class="hljs-number">0xFF</span>;         <span class="hljs-comment">// 翻转复位</span><br><br>  &#125;<br><br>  <span class="hljs-comment">/* If the effector map is more than EFF_MAX_PERC dense, just flag the</span><br><span class="hljs-comment">     whole thing as worth fuzzing, since we wouldn&#x27;t be saving much time</span><br><span class="hljs-comment">     anyway. */</span><br><br>  <span class="hljs-keyword">if</span> (eff_cnt != EFF_ALEN(len) &amp;&amp;<br>      eff_cnt * <span class="hljs-number">100</span> / EFF_ALEN(len) &gt; EFF_MAX_PERC) &#123;   <span class="hljs-comment">// eff_map密度大于90(默认)</span><br><br>    <span class="hljs-built_in">memset</span>(eff_map, <span class="hljs-number">1</span>, EFF_ALEN(len));  <span class="hljs-comment">// 将eff_map全部设置为1</span><br><br>    blocks_eff_select += EFF_ALEN(len); <span class="hljs-comment">// block_eff_select + EFF_ALEN(len)</span><br><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br><br>    blocks_eff_select += eff_cnt;       <span class="hljs-comment">// block_eff_select + eff_cnt</span><br><br>  &#125;<br><br>  blocks_eff_total += EFF_ALEN(len);    <span class="hljs-comment">// block_eff_total + EFF_ALEN(len)</span><br><br>  new_hit_cnt = queued_paths + unique_crashes;<br><br>  stage_finds[STAGE_FLIP8]  += new_hit_cnt - orig_hit_cnt;<br>  stage_cycles[STAGE_FLIP8] += stage_max;<br><br>  <span class="hljs-comment">/* Two walking bytes. */</span><br><br>  <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">goto</span> skip_bitflip;<br><br>  stage_name  = <span class="hljs-string">&quot;bitflip 16/8&quot;</span>;         <span class="hljs-comment">// bitflip 16/8，与 bitflip 8/8翻转过程相似，一次性翻转两个字节</span><br>  stage_short = <span class="hljs-string">&quot;flip16&quot;</span>;<br>  stage_cur   = <span class="hljs-number">0</span>;<br>  stage_max   = len - <span class="hljs-number">1</span>;<br><br>  orig_hit_cnt = new_hit_cnt;<br><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;<br><br>    <span class="hljs-comment">/* Let&#x27;s consult the effector map... */</span><br><br>    <span class="hljs-keyword">if</span> (!eff_map[EFF_APOS(i)] &amp;&amp; !eff_map[EFF_APOS(i + <span class="hljs-number">1</span>)]) &#123;   <span class="hljs-comment">// 检查eff_map连续两bytes是否为0</span><br>      stage_max--;      <span class="hljs-comment">// stage_max - 1</span><br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br><br>    stage_cur_byte = i;<br><br>    *(u16*)(out_buf + i) ^= <span class="hljs-number">0xFFFF</span>;     <span class="hljs-comment">// 翻转两个字节</span><br><br>    <span class="hljs-keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="hljs-keyword">goto</span> abandon_entry;<br>    stage_cur++;<br><br>    *(u16*)(out_buf + i) ^= <span class="hljs-number">0xFFFF</span>;     <span class="hljs-comment">// 翻转复位</span><br><br><br>  &#125;<br><br>  new_hit_cnt = queued_paths + unique_crashes;<br><br>  stage_finds[STAGE_FLIP16]  += new_hit_cnt - orig_hit_cnt;<br>  stage_cycles[STAGE_FLIP16] += stage_max;<br><br>  <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">4</span>) <span class="hljs-keyword">goto</span> skip_bitflip;       <span class="hljs-comment">// 如果len &lt; 4，跳转到skip_bitflip</span><br><br>  <span class="hljs-comment">/* Four walking bytes. */</span><br><br>  stage_name  = <span class="hljs-string">&quot;bitflip 32/8&quot;</span>;         <span class="hljs-comment">// bitflip 32/8，与bitflip 8/8翻转策略一致，但是一次性翻转4bytes</span><br>  stage_short = <span class="hljs-string">&quot;flip32&quot;</span>;<br>  stage_cur   = <span class="hljs-number">0</span>;<br>  stage_max   = len - <span class="hljs-number">3</span>;<br><br>  orig_hit_cnt = new_hit_cnt;<br><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">3</span>; i++) &#123;<br><br>    <span class="hljs-comment">/* Let&#x27;s consult the effector map... */</span><br>    <span class="hljs-keyword">if</span> (!eff_map[EFF_APOS(i)] &amp;&amp; !eff_map[EFF_APOS(i + <span class="hljs-number">1</span>)] &amp;&amp;<br>        !eff_map[EFF_APOS(i + <span class="hljs-number">2</span>)] &amp;&amp; !eff_map[EFF_APOS(i + <span class="hljs-number">3</span>)]) &#123;       <span class="hljs-comment">// 检查eff_map连续4bytes是否为空</span><br>      stage_max--;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br><br>    stage_cur_byte = i;<br><br>    *(u32*)(out_buf + i) ^= <span class="hljs-number">0xFFFFFFFF</span>; <span class="hljs-comment">// 翻转4个字节</span><br><br>    <span class="hljs-keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="hljs-keyword">goto</span> abandon_entry;<br>    stage_cur++;<br><br>    *(u32*)(out_buf + i) ^= <span class="hljs-number">0xFFFFFFFF</span>; <span class="hljs-comment">// 翻转复位</span><br><br>  &#125;<br><br>  new_hit_cnt = queued_paths + unique_crashes;<br><br>  stage_finds[STAGE_FLIP32]  += new_hit_cnt - orig_hit_cnt;<br>  stage_cycles[STAGE_FLIP32] += stage_max;<br><br>skip_bitflip:<br><br>  <span class="hljs-keyword">if</span> (no_arith) <span class="hljs-keyword">goto</span> skip_arith;        <span class="hljs-comment">// 若no_arith不为空，跳转到skip_arith</span><br></code></pre></td></tr></table></figure>



<h4 id="ARITHMETIC-INC-x2F-DEC"><a href="#ARITHMETIC-INC-x2F-DEC" class="headerlink" title="ARITHMETIC INC&#x2F;DEC"></a>ARITHMETIC INC&#x2F;DEC</h4><p>对测试用例做简单的算术加减变异，不区分大小端。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 8-bit arithmetics. */</span> <br><br>  stage_name  = <span class="hljs-string">&quot;arith 8/8&quot;</span>;    <span class="hljs-comment">// 1byte算数的加减</span><br>  stage_short = <span class="hljs-string">&quot;arith8&quot;</span>;<br>  stage_cur   = <span class="hljs-number">0</span>;<br>  stage_max   = <span class="hljs-number">2</span> * len * ARITH_MAX;<br><br>  stage_val_type = STAGE_VAL_LE;<br><br>  orig_hit_cnt = new_hit_cnt;<br><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br><br>    u8 orig = out_buf[i];<br><br>    <span class="hljs-comment">/* Let&#x27;s consult the effector map... */</span><br><br>    <span class="hljs-keyword">if</span> (!eff_map[EFF_APOS(i)]) &#123;        <span class="hljs-comment">// 判断该字节对应eff_map是否有效</span><br>      stage_max -= <span class="hljs-number">2</span> * ARITH_MAX;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br><br>    stage_cur_byte = i;<br><br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt;= ARITH_MAX; j++) &#123;  <span class="hljs-comment">// j &lt;= 35</span><br><br>      u8 r = orig ^ (orig + j);<br><br>      <span class="hljs-comment">/* Do arithmetic operations only if the result couldn&#x27;t be a product</span><br><span class="hljs-comment">         of a bitflip. */</span><br>      <br>      <span class="hljs-comment">// 判断是否可以通过bitflip变异方式获得本次变异结果，若不可以，执行下面分支，否则跳过此阶段</span><br><br>      <span class="hljs-keyword">if</span> (!could_be_bitflip(r)) &#123;       <br><br>        stage_cur_val = j;<br>        out_buf[i] = orig + j;  <span class="hljs-comment">// 加法变异</span><br><br>        <span class="hljs-keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="hljs-keyword">goto</span> abandon_entry;<br>        stage_cur++;<br><br>      &#125; <span class="hljs-keyword">else</span> stage_max--;<br><br>      r =  orig ^ (orig - j);<br><br>      <span class="hljs-keyword">if</span> (!could_be_bitflip(r)) &#123;<br><br>        stage_cur_val = -j;<br>        out_buf[i] = orig - j;  <span class="hljs-comment">// 减法变异</span><br><br>        <span class="hljs-keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="hljs-keyword">goto</span> abandon_entry;<br>        stage_cur++;<br><br>      &#125; <span class="hljs-keyword">else</span> stage_max--;<br><br>      out_buf[i] = orig;        <span class="hljs-comment">// 恢复为原来的值</span><br><br>    &#125;<br><br>  &#125;<br><br>  new_hit_cnt = queued_paths + unique_crashes;<br><br>  stage_finds[STAGE_ARITH8]  += new_hit_cnt - orig_hit_cnt;<br>  stage_cycles[STAGE_ARITH8] += stage_max;<br><br>  <span class="hljs-comment">/* 16-bit arithmetics, both endians. */</span><br><br>  <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">goto</span> skip_arith;<br><br>  stage_name  = <span class="hljs-string">&quot;arith 16/8&quot;</span>;   <span class="hljs-comment">// arith 16/8 变异方式类似于arith 8/8，只是一次性处理2个字节</span><br>  stage_short = <span class="hljs-string">&quot;arith16&quot;</span>;<br>  stage_cur   = <span class="hljs-number">0</span>;<br>  stage_max   = <span class="hljs-number">4</span> * (len - <span class="hljs-number">1</span>) * ARITH_MAX;<br><br>  orig_hit_cnt = new_hit_cnt;<br><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;<br><br>    u16 orig = *(u16*)(out_buf + i);<br><br>    <span class="hljs-comment">/* Let&#x27;s consult the effector map... */</span><br><br>    <span class="hljs-keyword">if</span> (!eff_map[EFF_APOS(i)] &amp;&amp; !eff_map[EFF_APOS(i + <span class="hljs-number">1</span>)]) &#123;   <span class="hljs-comment">// 判断eff_map[EFF_APOS(i)]与eff_map[EFF_APOS(i + 1)]两个字节是否为空</span><br>      stage_max -= <span class="hljs-number">4</span> * ARITH_MAX;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br><br>    stage_cur_byte = i;<br><br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt;= ARITH_MAX; j++) &#123;<br><br>      u16 r1 = orig ^ (orig + j),       <span class="hljs-comment">// 小端</span><br>          r2 = orig ^ (orig - j),       <span class="hljs-comment">// 小端</span><br>          r3 = orig ^ SWAP16(SWAP16(orig) + j), <span class="hljs-comment">// 大端</span><br>          r4 = orig ^ SWAP16(SWAP16(orig) - j); <span class="hljs-comment">// 大端</span><br><br>      <span class="hljs-comment">/* Try little endian addition and subtraction first. Do it only</span><br><span class="hljs-comment">         if the operation would affect more than one byte (hence the </span><br><span class="hljs-comment">         &amp; 0xff overflow checks) and if it couldn&#x27;t be a product of</span><br><span class="hljs-comment">         a bitflip. */</span><br><br>      stage_val_type = STAGE_VAL_LE; <br><br>      <span class="hljs-keyword">if</span> ((orig &amp; <span class="hljs-number">0xff</span>) + j &gt; <span class="hljs-number">0xff</span> &amp;&amp; !could_be_bitflip(r1)) &#123;  <span class="hljs-comment">// 若r1不能通过bitflip得到，且(orig &amp; 0xff) + j &gt; 0xff</span><br><br>        stage_cur_val = j;<br>        *(u16*)(out_buf + i) = orig + j;        <span class="hljs-comment">// 加法变异</span><br><br>        <span class="hljs-keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="hljs-keyword">goto</span> abandon_entry;<br>        stage_cur++;<br> <br>      &#125; <span class="hljs-keyword">else</span> stage_max--;<br><br>      <span class="hljs-keyword">if</span> ((orig &amp; <span class="hljs-number">0xff</span>) &lt; j &amp;&amp; !could_be_bitflip(r2)) &#123; <span class="hljs-comment">// 若r2不能通过bitflip得到，且(orig &amp; 0xff) &lt; j</span><br><br>        stage_cur_val = -j;<br>        *(u16*)(out_buf + i) = orig - j;        <span class="hljs-comment">// 减法变异</span><br><br>        <span class="hljs-keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="hljs-keyword">goto</span> abandon_entry;<br>        stage_cur++;<br><br>      &#125; <span class="hljs-keyword">else</span> stage_max--;<br><br>      <span class="hljs-comment">/* Big endian comes next. Same deal. */</span><br><br>      stage_val_type = STAGE_VAL_BE;    <span class="hljs-comment">// 大端</span><br><br>      <span class="hljs-keyword">if</span> ((orig &gt;&gt; <span class="hljs-number">8</span>) + j &gt; <span class="hljs-number">0xff</span> &amp;&amp; !could_be_bitflip(r3)) &#123;    <span class="hljs-comment">// 若r3不能通过bitflip得到，且(orig &gt;&gt; 8) + j &gt; 0xff</span><br><br>        stage_cur_val = j;<br>        *(u16*)(out_buf + i) = SWAP16(SWAP16(orig) + j);        <span class="hljs-comment">// 大端加法变异</span><br><br>        <span class="hljs-keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="hljs-keyword">goto</span> abandon_entry;<br>        stage_cur++;<br><br>      &#125; <span class="hljs-keyword">else</span> stage_max--;<br><br>      <span class="hljs-keyword">if</span> ((orig &gt;&gt; <span class="hljs-number">8</span>) &lt; j &amp;&amp; !could_be_bitflip(r4)) &#123;   <span class="hljs-comment">// 若r1不能通过bitflip得到，且(orig &gt;&gt; 8) &lt; j</span><br><br>        stage_cur_val = -j;     <br>        *(u16*)(out_buf + i) = SWAP16(SWAP16(orig) - j);        <span class="hljs-comment">// 大端减法变异</span><br><br>        <span class="hljs-keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="hljs-keyword">goto</span> abandon_entry;<br>        stage_cur++;<br><br>      &#125; <span class="hljs-keyword">else</span> stage_max--;<br><br>      *(u16*)(out_buf + i) = orig;      <span class="hljs-comment">// 恢复原始值</span><br><br>    &#125;<br><br>  &#125;<br><br>  new_hit_cnt = queued_paths + unique_crashes;<br><br>  stage_finds[STAGE_ARITH16]  += new_hit_cnt - orig_hit_cnt;<br>  stage_cycles[STAGE_ARITH16] += stage_max;<br><br>  <span class="hljs-comment">/* 32-bit arithmetics, both endians. */</span><br><br>  <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">4</span>) <span class="hljs-keyword">goto</span> skip_arith;<br><br>  stage_name  = <span class="hljs-string">&quot;arith 32/8&quot;</span>;   <span class="hljs-comment">// arith 32/8，与arith 16/8类同，一次性处理4个字节，不再赘述</span><br>  stage_short = <span class="hljs-string">&quot;arith32&quot;</span>;<br>  stage_cur   = <span class="hljs-number">0</span>;<br>  stage_max   = <span class="hljs-number">4</span> * (len - <span class="hljs-number">3</span>) * ARITH_MAX;<br><br>  orig_hit_cnt = new_hit_cnt;<br><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">3</span>; i++) &#123;<br><br>    u32 orig = *(u32*)(out_buf + i);<br><br>    <span class="hljs-comment">/* Let&#x27;s consult the effector map... */</span><br><br>    <span class="hljs-keyword">if</span> (!eff_map[EFF_APOS(i)] &amp;&amp; !eff_map[EFF_APOS(i + <span class="hljs-number">1</span>)] &amp;&amp;<br>        !eff_map[EFF_APOS(i + <span class="hljs-number">2</span>)] &amp;&amp; !eff_map[EFF_APOS(i + <span class="hljs-number">3</span>)]) &#123;<br>      stage_max -= <span class="hljs-number">4</span> * ARITH_MAX;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br><br>    stage_cur_byte = i;<br><br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt;= ARITH_MAX; j++) &#123;<br><br>      u32 r1 = orig ^ (orig + j),<br>          r2 = orig ^ (orig - j),<br>          r3 = orig ^ SWAP32(SWAP32(orig) + j),<br>          r4 = orig ^ SWAP32(SWAP32(orig) - j);<br><br>      <span class="hljs-comment">/* Little endian first. Same deal as with 16-bit: we only want to</span><br><span class="hljs-comment">         try if the operation would have effect on more than two bytes. */</span><br><br>      stage_val_type = STAGE_VAL_LE;<br><br>      <span class="hljs-keyword">if</span> ((orig &amp; <span class="hljs-number">0xffff</span>) + j &gt; <span class="hljs-number">0xffff</span> &amp;&amp; !could_be_bitflip(r1)) &#123;<br><br>        stage_cur_val = j;<br>        *(u32*)(out_buf + i) = orig + j;<br><br>        <span class="hljs-keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="hljs-keyword">goto</span> abandon_entry;<br>        stage_cur++;<br><br>      &#125; <span class="hljs-keyword">else</span> stage_max--;<br><br>      <span class="hljs-keyword">if</span> ((orig &amp; <span class="hljs-number">0xffff</span>) &lt; j &amp;&amp; !could_be_bitflip(r2)) &#123;<br><br>        stage_cur_val = -j;<br>        *(u32*)(out_buf + i) = orig - j;<br><br>        <span class="hljs-keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="hljs-keyword">goto</span> abandon_entry;<br>        stage_cur++;<br><br>      &#125; <span class="hljs-keyword">else</span> stage_max--;<br><br>      <span class="hljs-comment">/* Big endian next. */</span><br><br>      stage_val_type = STAGE_VAL_BE;<br><br>      <span class="hljs-keyword">if</span> ((SWAP32(orig) &amp; <span class="hljs-number">0xffff</span>) + j &gt; <span class="hljs-number">0xffff</span> &amp;&amp; !could_be_bitflip(r3)) &#123;<br><br>        stage_cur_val = j;<br>        *(u32*)(out_buf + i) = SWAP32(SWAP32(orig) + j);<br><br>        <span class="hljs-keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="hljs-keyword">goto</span> abandon_entry;<br>        stage_cur++;<br><br>      &#125; <span class="hljs-keyword">else</span> stage_max--;<br><br>      <span class="hljs-keyword">if</span> ((SWAP32(orig) &amp; <span class="hljs-number">0xffff</span>) &lt; j &amp;&amp; !could_be_bitflip(r4)) &#123;<br><br>        stage_cur_val = -j;<br>        *(u32*)(out_buf + i) = SWAP32(SWAP32(orig) - j);<br><br>        <span class="hljs-keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="hljs-keyword">goto</span> abandon_entry;<br>        stage_cur++;<br><br>      &#125; <span class="hljs-keyword">else</span> stage_max--;<br><br>      *(u32*)(out_buf + i) = orig;<br><br>    &#125;<br><br>  &#125;<br><br>  new_hit_cnt = queued_paths + unique_crashes;<br><br>  stage_finds[STAGE_ARITH32]  += new_hit_cnt - orig_hit_cnt;<br>  stage_cycles[STAGE_ARITH32] += stage_max;<br><br>skip_arith:<br></code></pre></td></tr></table></figure>



<h4 id="INTERESTING-VALUES"><a href="#INTERESTING-VALUES" class="headerlink" title="INTERESTING VALUES"></a>INTERESTING VALUES</h4><p>将out_buf随机替换为AFL提供的interesting内容。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**********************</span><br><span class="hljs-comment">   * INTERESTING VALUES *       // Interesting，将outbuf中的字节替换成AFL内部的值</span><br><span class="hljs-comment">   **********************/</span><br><br>  stage_name  = <span class="hljs-string">&quot;interest 8/8&quot;</span>; <br>  stage_short = <span class="hljs-string">&quot;int8&quot;</span>;<br>  stage_cur   = <span class="hljs-number">0</span>;<br>  stage_max   = len * <span class="hljs-keyword">sizeof</span>(interesting_8);<br><br>  stage_val_type = STAGE_VAL_LE;<br><br>  orig_hit_cnt = new_hit_cnt;<br><br>  <span class="hljs-comment">/* Setting 8-bit integers. */</span><br><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br><br>    u8 orig = out_buf[i];<br><br>    <span class="hljs-comment">/* Let&#x27;s consult the effector map... */</span><br><br>    <span class="hljs-keyword">if</span> (!eff_map[EFF_APOS(i)]) &#123;        <span class="hljs-comment">// 判断eff_map是否有效</span><br>      stage_max -= <span class="hljs-keyword">sizeof</span>(interesting_8);<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br><br>    stage_cur_byte = i;<br><br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-keyword">sizeof</span>(interesting_8); j++) &#123;       <span class="hljs-comment">// 遍历interesting_8数组，判断是否能通过bitflip或者arith变异得到</span><br><br>      <span class="hljs-comment">/* Skip if the value could be a product of bitflips or arithmetics. */</span><br><br>      <span class="hljs-keyword">if</span> (could_be_bitflip(orig ^ (u8)interesting_8[j]) ||<br>          could_be_arith(orig, (u8)interesting_8[j], <span class="hljs-number">1</span>)) &#123;<br>        stage_max--;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br><br>      stage_cur_val = interesting_8[j];<br>      out_buf[i] = interesting_8[j];    <span class="hljs-comment">// 将out_buf[i]替换为interesting_8[j]</span><br><br>      <span class="hljs-keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="hljs-keyword">goto</span> abandon_entry;<br><br>      out_buf[i] = orig;        <span class="hljs-comment">// 恢复原始值</span><br>      stage_cur++;<br><br>    &#125;<br><br>  &#125;<br><br>  new_hit_cnt = queued_paths + unique_crashes;<br><br>  stage_finds[STAGE_INTEREST8]  += new_hit_cnt - orig_hit_cnt;<br>  stage_cycles[STAGE_INTEREST8] += stage_max;<br><br>  <span class="hljs-comment">/* Setting 16-bit integers, both endians. */</span><br><br>  <span class="hljs-keyword">if</span> (no_arith || len &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">goto</span> skip_interest;<br><br>  stage_name  = <span class="hljs-string">&quot;interest 16/8&quot;</span>;        <span class="hljs-comment">// interest 16/8，与interest 8/8阶段类似</span><br>  stage_short = <span class="hljs-string">&quot;int16&quot;</span>;<br>  stage_cur   = <span class="hljs-number">0</span>;<br>  stage_max   = <span class="hljs-number">2</span> * (len - <span class="hljs-number">1</span>) * (<span class="hljs-keyword">sizeof</span>(interesting_16) &gt;&gt; <span class="hljs-number">1</span>);<br><br>  orig_hit_cnt = new_hit_cnt;<br><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;       <span class="hljs-comment">// 判断连续eff_map是否不为0</span><br><br>    u16 orig = *(u16*)(out_buf + i);<br><br>    <span class="hljs-comment">/* Let&#x27;s consult the effector map... */</span><br><br>    <span class="hljs-keyword">if</span> (!eff_map[EFF_APOS(i)] &amp;&amp; !eff_map[EFF_APOS(i + <span class="hljs-number">1</span>)]) &#123;<br>      stage_max -= <span class="hljs-keyword">sizeof</span>(interesting_16);<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br><br>    stage_cur_byte = i;<br><br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-keyword">sizeof</span>(interesting_16) / <span class="hljs-number">2</span>; j++) &#123;  <span class="hljs-comment">// 循环遍历interesting_16数组</span><br><br>      stage_cur_val = interesting_16[j];<br><br>      <span class="hljs-comment">/* Skip if this could be a product of a bitflip, arithmetics,</span><br><span class="hljs-comment">         or single-byte interesting value insertion. */</span><br><br>      <span class="hljs-keyword">if</span> (!could_be_bitflip(orig ^ (u16)interesting_16[j]) &amp;&amp;<br>          !could_be_arith(orig, (u16)interesting_16[j], <span class="hljs-number">2</span>) &amp;&amp;<br>          !could_be_interest(orig, (u16)interesting_16[j], <span class="hljs-number">2</span>, <span class="hljs-number">0</span>)) &#123;     <span class="hljs-comment">// 判断是否可以通过bitflip，arith，或者interest 8/8变异得到</span><br><br>        stage_val_type = STAGE_VAL_LE;<br><br>        *(u16*)(out_buf + i) = interesting_16[j];       <span class="hljs-comment">// 替换为interesting_16[j]</span><br><br>        <span class="hljs-keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="hljs-keyword">goto</span> abandon_entry;<br>        stage_cur++;<br><br>      &#125; <span class="hljs-keyword">else</span> stage_max--;<br>      <br>      <span class="hljs-comment">// 大端</span><br>      <span class="hljs-keyword">if</span> ((u16)interesting_16[j] != SWAP16(interesting_16[j]) &amp;&amp;<br>          !could_be_bitflip(orig ^ SWAP16(interesting_16[j])) &amp;&amp;<br>          !could_be_arith(orig, SWAP16(interesting_16[j]), <span class="hljs-number">2</span>) &amp;&amp;<br>          !could_be_interest(orig, SWAP16(interesting_16[j]), <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)) &#123;<br><br>        stage_val_type = STAGE_VAL_BE;<br><br>        *(u16*)(out_buf + i) = SWAP16(interesting_16[j]);       <span class="hljs-comment">// 替换为intere[16]</span><br>        <span class="hljs-keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="hljs-keyword">goto</span> abandon_entry;<br>        stage_cur++;<br><br>      &#125; <span class="hljs-keyword">else</span> stage_max--;<br><br>    &#125;<br><br>    *(u16*)(out_buf + i) = orig;        <span class="hljs-comment">// 恢复原始值</span><br><br>  &#125;<br><br>  new_hit_cnt = queued_paths + unique_crashes;<br><br>  stage_finds[STAGE_INTEREST16]  += new_hit_cnt - orig_hit_cnt;<br>  stage_cycles[STAGE_INTEREST16] += stage_max;<br><br>  <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">4</span>) <span class="hljs-keyword">goto</span> skip_interest;<br><br>  <span class="hljs-comment">/* Setting 32-bit integers, both endians. */</span><br><br>  stage_name  = <span class="hljs-string">&quot;interest 32/8&quot;</span>;        <span class="hljs-comment">// interest 32/8，与interest 16/8阶段类似，不再赘述</span><br>  stage_short = <span class="hljs-string">&quot;int32&quot;</span>;<br>  stage_cur   = <span class="hljs-number">0</span>;<br>  stage_max   = <span class="hljs-number">2</span> * (len - <span class="hljs-number">3</span>) * (<span class="hljs-keyword">sizeof</span>(interesting_32) &gt;&gt; <span class="hljs-number">2</span>);<br><br>  orig_hit_cnt = new_hit_cnt;<br><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">3</span>; i++) &#123;<br><br>    u32 orig = *(u32*)(out_buf + i);<br><br>    <span class="hljs-comment">/* Let&#x27;s consult the effector map... */</span><br><br>    <span class="hljs-keyword">if</span> (!eff_map[EFF_APOS(i)] &amp;&amp; !eff_map[EFF_APOS(i + <span class="hljs-number">1</span>)] &amp;&amp;<br>        !eff_map[EFF_APOS(i + <span class="hljs-number">2</span>)] &amp;&amp; !eff_map[EFF_APOS(i + <span class="hljs-number">3</span>)]) &#123;       <span class="hljs-comment">// 判断相邻4位是否有效</span><br>      stage_max -= <span class="hljs-keyword">sizeof</span>(interesting_32) &gt;&gt; <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br><br>    stage_cur_byte = i;<br><br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-keyword">sizeof</span>(interesting_32) / <span class="hljs-number">4</span>; j++) &#123;<br><br>      stage_cur_val = interesting_32[j];<br><br>      <span class="hljs-comment">/* Skip if this could be a product of a bitflip, arithmetics,</span><br><span class="hljs-comment">         or word interesting value insertion. */</span><br><br>      <span class="hljs-keyword">if</span> (!could_be_bitflip(orig ^ (u32)interesting_32[j]) &amp;&amp;<br>          !could_be_arith(orig, interesting_32[j], <span class="hljs-number">4</span>) &amp;&amp;<br>          !could_be_interest(orig, interesting_32[j], <span class="hljs-number">4</span>, <span class="hljs-number">0</span>)) &#123;<br><br>        stage_val_type = STAGE_VAL_LE;<br><br>        *(u32*)(out_buf + i) = interesting_32[j];<br><br>        <span class="hljs-keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="hljs-keyword">goto</span> abandon_entry;<br>        stage_cur++;<br><br>      &#125; <span class="hljs-keyword">else</span> stage_max--;<br><br>      <span class="hljs-keyword">if</span> ((u32)interesting_32[j] != SWAP32(interesting_32[j]) &amp;&amp;<br>          !could_be_bitflip(orig ^ SWAP32(interesting_32[j])) &amp;&amp;<br>          !could_be_arith(orig, SWAP32(interesting_32[j]), <span class="hljs-number">4</span>) &amp;&amp;<br>          !could_be_interest(orig, SWAP32(interesting_32[j]), <span class="hljs-number">4</span>, <span class="hljs-number">1</span>)) &#123;<br><br>        stage_val_type = STAGE_VAL_BE;<br><br>        *(u32*)(out_buf + i) = SWAP32(interesting_32[j]);<br>        <span class="hljs-keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="hljs-keyword">goto</span> abandon_entry;<br>        stage_cur++;<br><br>      &#125; <span class="hljs-keyword">else</span> stage_max--;<br><br>    &#125;<br><br>    *(u32*)(out_buf + i) = orig;<br><br>  &#125;<br><br>  new_hit_cnt = queued_paths + unique_crashes;<br><br>  stage_finds[STAGE_INTEREST32]  += new_hit_cnt - orig_hit_cnt;<br>  stage_cycles[STAGE_INTEREST32] += stage_max;<br><br>skip_interest:<br></code></pre></td></tr></table></figure>



<h4 id="DICTIONARY-STUFF"><a href="#DICTIONARY-STUFF" class="headerlink" title="DICTIONARY STUFF"></a>DICTIONARY STUFF</h4><p>基于用户提供的extras，以及自动生成的a_extras进行替换和插入变异。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/********************</span><br><span class="hljs-comment">   * DICTIONARY STUFF * // 基于用户提供的extra token进行一定的变异，主要有替换和插入两种模式</span><br><span class="hljs-comment">   ********************/</span><br><br>  <span class="hljs-keyword">if</span> (!extras_cnt) <span class="hljs-keyword">goto</span> skip_user_extras;       <span class="hljs-comment">// 若extras_cnt为空，跳转到skip_user_extras</span><br><br>  <span class="hljs-comment">/* Overwrite with user-supplied extras. */</span><br><br>  stage_name  = <span class="hljs-string">&quot;user extras (over)&quot;</span>;   <span class="hljs-comment">// user extras (over)</span><br>  stage_short = <span class="hljs-string">&quot;ext_UO&quot;</span>;<br>  stage_cur   = <span class="hljs-number">0</span>;<br>  stage_max   = extras_cnt * len;<br><br>  stage_val_type = STAGE_VAL_NONE;<br><br>  orig_hit_cnt = new_hit_cnt;<br><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br><br>    u32 last_len = <span class="hljs-number">0</span>;<br><br>    stage_cur_byte = i;<br><br>    <span class="hljs-comment">/* Extras are sorted by size, from smallest to largest. This means</span><br><span class="hljs-comment">       that we don&#x27;t have to worry about restoring the buffer in</span><br><span class="hljs-comment">       between writes at a particular offset determined by the outer</span><br><span class="hljs-comment">       loop. */</span><br><br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; extras_cnt; j++) &#123;  <span class="hljs-comment">// 遍历用户提供的extras</span><br><br>      <span class="hljs-comment">/* Skip extras probabilistically if extras_cnt &gt; MAX_DET_EXTRAS. Also</span><br><span class="hljs-comment">         skip them if there&#x27;s no room to insert the payload, if the token</span><br><span class="hljs-comment">         is redundant, or if its entire span has no bytes set in the effector</span><br><span class="hljs-comment">         map. */</span><br>      <br>      <span class="hljs-comment">// 若extras_cnt &gt; 200 且 UR(extras_cnt) &gt;= 200(随机性) 或者 extras[j]的长度大于len - i</span><br>      <span class="hljs-comment">// 或者extras[j].data与out_buf相同，或者没有在指定范围的eff_map找到1，跳过此stage</span><br>      <span class="hljs-keyword">if</span> ((extras_cnt &gt; MAX_DET_EXTRAS &amp;&amp; UR(extras_cnt) &gt;= MAX_DET_EXTRAS) ||<br>          extras[j].len &gt; len - i ||<br>          !<span class="hljs-built_in">memcmp</span>(extras[j].data, out_buf + i, extras[j].len) ||<br>          !<span class="hljs-built_in">memchr</span>(eff_map + EFF_APOS(i), <span class="hljs-number">1</span>, EFF_SPAN_ALEN(i, extras[j].len))) &#123;<br><br>        stage_max--;<br>        <span class="hljs-keyword">continue</span>;<br><br>      &#125;<br><br>      last_len = extras[j].len;<br>      <span class="hljs-built_in">memcpy</span>(out_buf + i, extras[j].data, last_len);    <span class="hljs-comment">// 将out_buf替换为extras[j]</span><br><br>      <span class="hljs-keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="hljs-keyword">goto</span> abandon_entry;<br><br>      stage_cur++;<br><br>    &#125;<br><br>    <span class="hljs-comment">/* Restore all the clobbered memory. */</span><br>    <span class="hljs-built_in">memcpy</span>(out_buf + i, in_buf + i, last_len);  <span class="hljs-comment">// 恢复原始值</span><br><br>  &#125;<br><br>  new_hit_cnt = queued_paths + unique_crashes;<br><br>  stage_finds[STAGE_EXTRAS_UO]  += new_hit_cnt - orig_hit_cnt;<br>  stage_cycles[STAGE_EXTRAS_UO] += stage_max;<br><br>  <span class="hljs-comment">/* Insertion of user-supplied extras. */</span><br><br>  stage_name  = <span class="hljs-string">&quot;user extras (insert)&quot;</span>; <span class="hljs-comment">// user extras (insert)</span><br>  stage_short = <span class="hljs-string">&quot;ext_UI&quot;</span>;<br>  stage_cur   = <span class="hljs-number">0</span>;<br>  stage_max   = extras_cnt * len;<br><br>  orig_hit_cnt = new_hit_cnt;<br><br>  ex_tmp = ck_alloc(len + MAX_DICT_FILE);<br><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= len; i++) &#123;<br><br>    stage_cur_byte = i;<br><br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; extras_cnt; j++) &#123;<br><br>      <span class="hljs-keyword">if</span> (len + extras[j].len &gt; MAX_FILE) &#123;     <span class="hljs-comment">// 若len + extras[j].len &gt; MAX_FILE，跳过此阶段</span><br>        stage_max--; <br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br><br>      <span class="hljs-comment">/* Insert token */</span><br>      <span class="hljs-built_in">memcpy</span>(ex_tmp + i, extras[j].data, extras[j].len);        <span class="hljs-comment">// 从ex_tmp + i开始插入extras[j].len长度的数据</span><br><br>      <span class="hljs-comment">/* Copy tail */</span><br>      <span class="hljs-built_in">memcpy</span>(ex_tmp + i + extras[j].len, out_buf + i, len - i); <span class="hljs-comment">// 将剩下的数据复制到ex_tmp</span><br><br>      <span class="hljs-keyword">if</span> (common_fuzz_stuff(argv, ex_tmp, len + extras[j].len)) &#123;<br>        ck_free(ex_tmp);<br>        <span class="hljs-keyword">goto</span> abandon_entry;<br>      &#125;<br><br>      stage_cur++;<br><br>    &#125;<br><br>    <span class="hljs-comment">/* Copy head */</span><br>    ex_tmp[i] = out_buf[i];     <span class="hljs-comment">// 恢复原来数据</span><br><br>  &#125;<br><br>  ck_free(ex_tmp);<br><br>  new_hit_cnt = queued_paths + unique_crashes;<br><br>  stage_finds[STAGE_EXTRAS_UI]  += new_hit_cnt - orig_hit_cnt;<br>  stage_cycles[STAGE_EXTRAS_UI] += stage_max;<br><br>skip_user_extras:<br><br>  <span class="hljs-keyword">if</span> (!a_extras_cnt) <span class="hljs-keyword">goto</span> skip_extras;<br><br>  stage_name  = <span class="hljs-string">&quot;auto extras (over)&quot;</span>;   <span class="hljs-comment">// auto extras (over)， 与 user extras (over)类似，这里替换的是a_extras</span><br>  stage_short = <span class="hljs-string">&quot;ext_AO&quot;</span>;<br>  stage_cur   = <span class="hljs-number">0</span>;<br>  stage_max   = MIN(a_extras_cnt, USE_AUTO_EXTRAS) * len;<br><br>  stage_val_type = STAGE_VAL_NONE;<br><br>  orig_hit_cnt = new_hit_cnt;<br><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br><br>    u32 last_len = <span class="hljs-number">0</span>;<br><br>    stage_cur_byte = i;<br><br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; MIN(a_extras_cnt, USE_AUTO_EXTRAS); j++) &#123;<br><br>      <span class="hljs-comment">/* See the comment in the earlier code; extras are sorted by size. */</span><br><br>      <span class="hljs-keyword">if</span> (a_extras[j].len &gt; len - i ||<br>          !<span class="hljs-built_in">memcmp</span>(a_extras[j].data, out_buf + i, a_extras[j].len) ||<br>          !<span class="hljs-built_in">memchr</span>(eff_map + EFF_APOS(i), <span class="hljs-number">1</span>, EFF_SPAN_ALEN(i, a_extras[j].len))) &#123;<br><br>        stage_max--;<br>        <span class="hljs-keyword">continue</span>;<br><br>      &#125;<br><br>      last_len = a_extras[j].len;<br>      <span class="hljs-built_in">memcpy</span>(out_buf + i, a_extras[j].data, last_len);  <span class="hljs-comment">// 替换out_buf + i的数据为a_extras[j].data</span><br><br>      <span class="hljs-keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="hljs-keyword">goto</span> abandon_entry;<br><br>      stage_cur++;<br><br>    &#125;<br><br>    <span class="hljs-comment">/* Restore all the clobbered memory. */</span><br>    <span class="hljs-built_in">memcpy</span>(out_buf + i, in_buf + i, last_len);  <span class="hljs-comment">// 恢复原始数据</span><br><br>  &#125;<br><br>  new_hit_cnt = queued_paths + unique_crashes;<br><br>  stage_finds[STAGE_EXTRAS_AO]  += new_hit_cnt - orig_hit_cnt;<br>  stage_cycles[STAGE_EXTRAS_AO] += stage_max;<br><br>skip_extras:<br><br>  <span class="hljs-comment">/* If we made this to here without jumping to havoc_stage or abandon_entry,</span><br><span class="hljs-comment">     we&#x27;re properly done with deterministic steps and can mark it as such</span><br><span class="hljs-comment">     in the .state/ directory. */</span><br><br>  <span class="hljs-keyword">if</span> (!queue_cur-&gt;passed_det) mark_as_det_done(queue_cur);      <span class="hljs-comment">// 若queue_cur-&gt;passed_det为空，调用mark_as_det_done对cur进行标记</span><br><br></code></pre></td></tr></table></figure>



<h4 id="RANDOM-HAVOC"><a href="#RANDOM-HAVOC" class="headerlink" title="RANDOM HAVOC"></a>RANDOM HAVOC</h4><p>随机变异阶段，有很大的随机性。</p>
<p>主要有以下变异方式：</p>
<ol start="0">
<li><p>随机翻转out_buf字节</p>
</li>
<li><p>随机选中interesting_8的值替换out_buf中的随机byte</p>
</li>
<li><p>随机选中interesting_16的值替换out_buf中的随机2bytes</p>
</li>
<li><p>随机选中interesting_32的值替换out_buf中的随机4bytes</p>
</li>
<li><p>随机选择out_buf中的1byte并随机减去一个值</p>
</li>
<li><p>随机选择out_buf中的1byte并随机加上一个值</p>
</li>
<li><p>随机选择out_buf中的2bytes并随机减去一个值</p>
</li>
<li><p>随机选择out_buf中的2bytes并随机加去一个值</p>
</li>
<li><p>随机选择out_buf中的4bytes并随机减去一个值</p>
</li>
<li><p>随机选择out_buf中的4bytes并随机加上一个值</p>
</li>
<li><p>随机选择out_buf中1byte与1~255中某个值进行异或</p>
</li>
<li><p>随机删除随机长度随机位置的值</p>
</li>
<li><p>随机删除随机长度随机位置的值</p>
</li>
<li><p>随机插入随机长度值</p>
</li>
<li><p>随机替换随机长度值</p>
</li>
<li><p>指定dict时，随机替换token</p>
</li>
<li><p>随机插入token</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-comment">/****************</span><br><span class="hljs-comment">   * RANDOM HAVOC *     // 随机变异阶段</span><br><span class="hljs-comment">   ****************/</span><br><br>havoc_stage:<br><br>  stage_cur_byte = <span class="hljs-number">-1</span>;<br><br>  <span class="hljs-comment">/* The havoc stage mutation code is also invoked when splicing files; if the</span><br><span class="hljs-comment">     splice_cycle variable is set, generate different descriptions and such. */</span><br><br>  <span class="hljs-keyword">if</span> (!splice_cycle) &#123;  <span class="hljs-comment">// 若splice_cycle为空，标记为havoc阶段</span><br><br>    stage_name  = <span class="hljs-string">&quot;havoc&quot;</span>;<br>    stage_short = <span class="hljs-string">&quot;havoc&quot;</span>;<br>    stage_max   = (doing_det ? HAVOC_CYCLES_INIT : HAVOC_CYCLES) *<br>                  perf_score / havoc_div / <span class="hljs-number">100</span>;<br><br>  &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// 否则，标记为splice阶段</span><br><br>    <span class="hljs-type">static</span> u8 tmp[<span class="hljs-number">32</span>];<br><br>    perf_score = orig_perf;<br><br>    <span class="hljs-built_in">sprintf</span>(tmp, <span class="hljs-string">&quot;splice %u&quot;</span>, splice_cycle);<br>    stage_name  = tmp;<br>    stage_short = <span class="hljs-string">&quot;splice&quot;</span>;<br>    stage_max   = SPLICE_HAVOC * perf_score / havoc_div / <span class="hljs-number">100</span>;<br><br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (stage_max &lt; HAVOC_MIN) stage_max = HAVOC_MIN;<br><br>  temp_len = len;<br><br>  orig_hit_cnt = queued_paths + unique_crashes;<br><br>  havoc_queued = queued_paths;<br><br>  <span class="hljs-comment">/* We essentially just do several thousand runs (depending on perf_score)</span><br><span class="hljs-comment">     where we take the input file and make random stacked tweaks. */</span><br><br>  <span class="hljs-keyword">for</span> (stage_cur = <span class="hljs-number">0</span>; stage_cur &lt; stage_max; stage_cur++) &#123;<br><br>    u32 use_stacking = <span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">1</span> + UR(HAVOC_STACK_POW2)); <span class="hljs-comment">// 随机设置switch轮数</span><br><br>    stage_cur_val = use_stacking;<br> <br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; use_stacking; i++) &#123;<br><br>      <span class="hljs-keyword">switch</span> (UR(<span class="hljs-number">15</span> + ((extras_cnt + a_extras_cnt) ? <span class="hljs-number">2</span> : <span class="hljs-number">0</span>))) &#123; <span class="hljs-comment">// 随机产生值作为case</span><br><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-comment">// 随机翻转out_buf字节</span><br><br>          <span class="hljs-comment">/* Flip a single bit somewhere. Spooky! */</span><br><br>          FLIP_BIT(out_buf, UR(temp_len &lt;&lt; <span class="hljs-number">3</span>));<br>          <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-comment">// 随机选中interesting_8的值替换out_buf中的随机byte</span><br><br>          <span class="hljs-comment">/* Set byte to interesting value. */</span><br><br>          out_buf[UR(temp_len)] = interesting_8[UR(<span class="hljs-keyword">sizeof</span>(interesting_8))];<br>          <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-comment">// 随机选中interesting_16的值替换out_buf中的随机2bytes</span><br><br>          <span class="hljs-comment">/* Set word to interesting value, randomly choosing endian. */</span><br><br>          <span class="hljs-keyword">if</span> (temp_len &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">break</span>;<br><br>          <span class="hljs-keyword">if</span> (UR(<span class="hljs-number">2</span>)) &#123;<br><br>            *(u16*)(out_buf + UR(temp_len - <span class="hljs-number">1</span>)) =<br>              interesting_16[UR(<span class="hljs-keyword">sizeof</span>(interesting_16) &gt;&gt; <span class="hljs-number">1</span>)];<br><br>          &#125; <span class="hljs-keyword">else</span> &#123;<br><br>            *(u16*)(out_buf + UR(temp_len - <span class="hljs-number">1</span>)) = SWAP16(<br>              interesting_16[UR(<span class="hljs-keyword">sizeof</span>(interesting_16) &gt;&gt; <span class="hljs-number">1</span>)]);<br><br>          &#125;<br><br>          <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <span class="hljs-comment">// 随机选中interesting_32的值替换out_buf中的随机4bytes</span><br><br>          <span class="hljs-comment">/* Set dword to interesting value, randomly choosing endian. */</span><br><br>          <span class="hljs-keyword">if</span> (temp_len &lt; <span class="hljs-number">4</span>) <span class="hljs-keyword">break</span>;<br><br>          <span class="hljs-keyword">if</span> (UR(<span class="hljs-number">2</span>)) &#123;<br>  <br>            *(u32*)(out_buf + UR(temp_len - <span class="hljs-number">3</span>)) =<br>              interesting_32[UR(<span class="hljs-keyword">sizeof</span>(interesting_32) &gt;&gt; <span class="hljs-number">2</span>)];<br><br>          &#125; <span class="hljs-keyword">else</span> &#123;<br><br>            *(u32*)(out_buf + UR(temp_len - <span class="hljs-number">3</span>)) = SWAP32(<br>              interesting_32[UR(<span class="hljs-keyword">sizeof</span>(interesting_32) &gt;&gt; <span class="hljs-number">2</span>)]);<br><br>          &#125;<br><br>          <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: <span class="hljs-comment">// 随机选择out_buf中的1byte并随机减去一个值</span><br><br>          <span class="hljs-comment">/* Randomly subtract from byte. */</span><br><br>          out_buf[UR(temp_len)] -= <span class="hljs-number">1</span> + UR(ARITH_MAX);<br>          <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>: <span class="hljs-comment">// 随机选择out_buf中的1byte并随机加上一个值</span><br><br>          <span class="hljs-comment">/* Randomly add to byte. */</span><br><br>          out_buf[UR(temp_len)] += <span class="hljs-number">1</span> + UR(ARITH_MAX);<br>          <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>: <span class="hljs-comment">// 随机选择out_buf中的2bytes并随机减去一个值</span><br><br>          <span class="hljs-comment">/* Randomly subtract from word, random endian. */</span><br><br>          <span class="hljs-keyword">if</span> (temp_len &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">break</span>;<br><br>          <span class="hljs-keyword">if</span> (UR(<span class="hljs-number">2</span>)) &#123;<br><br>            u32 pos = UR(temp_len - <span class="hljs-number">1</span>);<br><br>            *(u16*)(out_buf + pos) -= <span class="hljs-number">1</span> + UR(ARITH_MAX);<br><br>          &#125; <span class="hljs-keyword">else</span> &#123;<br><br>            u32 pos = UR(temp_len - <span class="hljs-number">1</span>);<br>            u16 num = <span class="hljs-number">1</span> + UR(ARITH_MAX);<br><br>            *(u16*)(out_buf + pos) =<br>              SWAP16(SWAP16(*(u16*)(out_buf + pos)) - num);<br><br>          &#125;<br><br>          <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>: <span class="hljs-comment">// 随机选择out_buf中的2bytes并随机加去一个值</span><br><br>          <span class="hljs-comment">/* Randomly add to word, random endian. */</span><br><br>          <span class="hljs-keyword">if</span> (temp_len &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">break</span>;<br><br>          <span class="hljs-keyword">if</span> (UR(<span class="hljs-number">2</span>)) &#123;<br><br>            u32 pos = UR(temp_len - <span class="hljs-number">1</span>);<br><br>            *(u16*)(out_buf + pos) += <span class="hljs-number">1</span> + UR(ARITH_MAX);<br><br>          &#125; <span class="hljs-keyword">else</span> &#123;<br><br>            u32 pos = UR(temp_len - <span class="hljs-number">1</span>);<br>            u16 num = <span class="hljs-number">1</span> + UR(ARITH_MAX);<br><br>            *(u16*)(out_buf + pos) =<br>              SWAP16(SWAP16(*(u16*)(out_buf + pos)) + num);<br><br>          &#125;<br><br>          <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>: <span class="hljs-comment">// 随机选择out_buf中的4bytes并随机减去一个值</span><br><br>          <span class="hljs-comment">/* Randomly subtract from dword, random endian. */</span><br><br>          <span class="hljs-keyword">if</span> (temp_len &lt; <span class="hljs-number">4</span>) <span class="hljs-keyword">break</span>;<br><br>          <span class="hljs-keyword">if</span> (UR(<span class="hljs-number">2</span>)) &#123;<br><br>            u32 pos = UR(temp_len - <span class="hljs-number">3</span>);<br><br>            *(u32*)(out_buf + pos) -= <span class="hljs-number">1</span> + UR(ARITH_MAX);<br><br>          &#125; <span class="hljs-keyword">else</span> &#123;<br><br>            u32 pos = UR(temp_len - <span class="hljs-number">3</span>);<br>            u32 num = <span class="hljs-number">1</span> + UR(ARITH_MAX);<br><br>            *(u32*)(out_buf + pos) =<br>              SWAP32(SWAP32(*(u32*)(out_buf + pos)) - num);<br><br>          &#125;<br><br>          <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>: <span class="hljs-comment">// 随机选择out_buf中的4bytes并随机加上一个值</span><br><br>          <span class="hljs-comment">/* Randomly add to dword, random endian. */</span><br><br>          <span class="hljs-keyword">if</span> (temp_len &lt; <span class="hljs-number">4</span>) <span class="hljs-keyword">break</span>;<br><br>          <span class="hljs-keyword">if</span> (UR(<span class="hljs-number">2</span>)) &#123;<br><br>            u32 pos = UR(temp_len - <span class="hljs-number">3</span>);<br><br>            *(u32*)(out_buf + pos) += <span class="hljs-number">1</span> + UR(ARITH_MAX);<br><br>          &#125; <span class="hljs-keyword">else</span> &#123;<br><br>            u32 pos = UR(temp_len - <span class="hljs-number">3</span>);<br>            u32 num = <span class="hljs-number">1</span> + UR(ARITH_MAX);<br><br>            *(u32*)(out_buf + pos) =<br>              SWAP32(SWAP32(*(u32*)(out_buf + pos)) + num);<br><br>          &#125;<br><br>          <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:        <span class="hljs-comment">// 随机选择out_buf中1byte与1~255中某个值进行异或</span><br><br>          <span class="hljs-comment">/* Just set a random byte to a random value. Because,</span><br><span class="hljs-comment">             why not. We use XOR with 1-255 to eliminate the</span><br><span class="hljs-comment">             possibility of a no-op. */</span><br><br>          out_buf[UR(temp_len)] ^= <span class="hljs-number">1</span> + UR(<span class="hljs-number">255</span>);<br>          <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">11</span> ... <span class="hljs-number">12</span>: &#123;       <span class="hljs-comment">// 随机删除随机长度随机位置的值</span><br><br>            <span class="hljs-comment">/* Delete bytes. We&#x27;re making this a bit more likely</span><br><span class="hljs-comment">               than insertion (the next option) in hopes of keeping</span><br><span class="hljs-comment">               files reasonably small. */</span><br><br>            u32 del_from, del_len;<br><br>            <span class="hljs-keyword">if</span> (temp_len &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-comment">/* Don&#x27;t delete too much. */</span><br><br>            del_len = choose_block_len(temp_len - <span class="hljs-number">1</span>);   <span class="hljs-comment">// 随机选取长度</span><br><br>            del_from = UR(temp_len - del_len + <span class="hljs-number">1</span>);      <span class="hljs-comment">// 随机选取删除位置</span><br><br>            memmove(out_buf + del_from, out_buf + del_from + del_len,<br>                    temp_len - del_from - del_len);<br><br>            temp_len -= del_len;<br><br>            <span class="hljs-keyword">break</span>;<br><br>          &#125;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">13</span>:        <span class="hljs-comment">// 随机插入</span><br><br>          <span class="hljs-keyword">if</span> (temp_len + HAVOC_BLK_XL &lt; MAX_FILE) &#123;     <span class="hljs-comment">// temp_len + 32768 &lt; 1024 * 1024</span><br><br>            <span class="hljs-comment">/* Clone bytes (75%) or insert a block of constant bytes (25%). */</span><br><br>            u8  actually_clone = UR(<span class="hljs-number">4</span>);<br>            u32 clone_from, clone_to, clone_len;<br>            u8* new_buf;<br><br>            <span class="hljs-keyword">if</span> (actually_clone) &#123;       <span class="hljs-comment">// 75%</span><br><br>              clone_len  = choose_block_len(temp_len);<br>              clone_from = UR(temp_len - clone_len + <span class="hljs-number">1</span>);<br><br>            &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 25%</span><br><br>              clone_len = choose_block_len(HAVOC_BLK_XL);<br>              clone_from = <span class="hljs-number">0</span>;<br><br>            &#125;<br><br>            clone_to   = UR(temp_len);<br><br>            new_buf = ck_alloc_nozero(temp_len + clone_len);<br><br>            <span class="hljs-comment">/* Head */</span><br><br>            <span class="hljs-built_in">memcpy</span>(new_buf, out_buf, clone_to);<br><br>            <span class="hljs-comment">/* Inserted part */</span><br><br>            <span class="hljs-keyword">if</span> (actually_clone)<br>              <span class="hljs-built_in">memcpy</span>(new_buf + clone_to, out_buf + clone_from, clone_len);<br>            <span class="hljs-keyword">else</span><br>              <span class="hljs-built_in">memset</span>(new_buf + clone_to,<br>                     UR(<span class="hljs-number">2</span>) ? UR(<span class="hljs-number">256</span>) : out_buf[UR(temp_len)], clone_len);<br><br>            <span class="hljs-comment">/* Tail */</span><br>            <span class="hljs-built_in">memcpy</span>(new_buf + clone_to + clone_len, out_buf + clone_to,<br>                   temp_len - clone_to);<br><br>            ck_free(out_buf);<br>            out_buf = new_buf;<br>            temp_len += clone_len;<br><br>          &#125;<br><br>          <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">14</span>: &#123;      <span class="hljs-comment">// 随机替换</span><br><br>            <span class="hljs-comment">/* Overwrite bytes with a randomly selected chunk (75%) or fixed</span><br><span class="hljs-comment">               bytes (25%). */</span><br><br>            u32 copy_from, copy_to, copy_len;<br><br>            <span class="hljs-keyword">if</span> (temp_len &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">break</span>;<br><br>            copy_len  = choose_block_len(temp_len - <span class="hljs-number">1</span>);<br><br>            copy_from = UR(temp_len - copy_len + <span class="hljs-number">1</span>);<br>            copy_to   = UR(temp_len - copy_len + <span class="hljs-number">1</span>);<br><br>            <span class="hljs-keyword">if</span> (UR(<span class="hljs-number">4</span>)) &#123;        <span class="hljs-comment">// 75%</span><br><br>              <span class="hljs-keyword">if</span> (copy_from != copy_to)<br>                memmove(out_buf + copy_to, out_buf + copy_from, copy_len);<br><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-built_in">memset</span>(out_buf + copy_to,<br>                          UR(<span class="hljs-number">2</span>) ? UR(<span class="hljs-number">256</span>) : out_buf[UR(temp_len)], copy_len);<br><br>            <span class="hljs-keyword">break</span>;<br><br>          &#125;<br><br>        <span class="hljs-comment">/* Values 15 and 16 can be selected only if there are any extras</span><br><span class="hljs-comment">           present in the dictionaries. */</span><br><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">15</span>: &#123;      <span class="hljs-comment">// 指定dict时，随机替换token</span><br><br>            <span class="hljs-comment">/* Overwrite bytes with an extra. */</span><br><br>            <span class="hljs-keyword">if</span> (!extras_cnt || (a_extras_cnt &amp;&amp; UR(<span class="hljs-number">2</span>))) &#123;<br><br>              <span class="hljs-comment">/* No user-specified extras or odds in our favor. Let&#x27;s use an</span><br><span class="hljs-comment">                 auto-detected one. */</span><br><br>              u32 use_extra = UR(a_extras_cnt);<br>              u32 extra_len = a_extras[use_extra].len;<br>              u32 insert_at;<br><br>              <span class="hljs-keyword">if</span> (extra_len &gt; temp_len) <span class="hljs-keyword">break</span>;<br><br>              insert_at = UR(temp_len - extra_len + <span class="hljs-number">1</span>);<br>              <span class="hljs-built_in">memcpy</span>(out_buf + insert_at, a_extras[use_extra].data, extra_len);<br><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br><br>              <span class="hljs-comment">/* No auto extras or odds in our favor. Use the dictionary. */</span><br><br>              u32 use_extra = UR(extras_cnt);<br>              u32 extra_len = extras[use_extra].len;<br>              u32 insert_at;<br><br>              <span class="hljs-keyword">if</span> (extra_len &gt; temp_len) <span class="hljs-keyword">break</span>;<br><br>              insert_at = UR(temp_len - extra_len + <span class="hljs-number">1</span>);<br>              <span class="hljs-built_in">memcpy</span>(out_buf + insert_at, extras[use_extra].data, extra_len);<br><br>            &#125;<br><br>            <span class="hljs-keyword">break</span>;<br><br>          &#125;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">16</span>: &#123;      <span class="hljs-comment">// 随机插入token</span><br><br>            u32 use_extra, extra_len, insert_at = UR(temp_len + <span class="hljs-number">1</span>);<br>            u8* new_buf;<br><br>            <span class="hljs-comment">/* Insert an extra. Do the same dice-rolling stuff as for the</span><br><span class="hljs-comment">               previous case. */</span><br><br>            <span class="hljs-keyword">if</span> (!extras_cnt || (a_extras_cnt &amp;&amp; UR(<span class="hljs-number">2</span>))) &#123;<br><br>              use_extra = UR(a_extras_cnt);<br>              extra_len = a_extras[use_extra].len;<br><br>              <span class="hljs-keyword">if</span> (temp_len + extra_len &gt;= MAX_FILE) <span class="hljs-keyword">break</span>;<br><br>              new_buf = ck_alloc_nozero(temp_len + extra_len);<br><br>              <span class="hljs-comment">/* Head */</span><br>              <span class="hljs-built_in">memcpy</span>(new_buf, out_buf, insert_at);<br><br>              <span class="hljs-comment">/* Inserted part */</span><br>              <span class="hljs-built_in">memcpy</span>(new_buf + insert_at, a_extras[use_extra].data, extra_len);<br><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br><br>              use_extra = UR(extras_cnt);<br>              extra_len = extras[use_extra].len;<br><br>              <span class="hljs-keyword">if</span> (temp_len + extra_len &gt;= MAX_FILE) <span class="hljs-keyword">break</span>;<br><br>              new_buf = ck_alloc_nozero(temp_len + extra_len);<br><br>              <span class="hljs-comment">/* Head */</span><br>              <span class="hljs-built_in">memcpy</span>(new_buf, out_buf, insert_at);<br><br>              <span class="hljs-comment">/* Inserted part */</span><br>              <span class="hljs-built_in">memcpy</span>(new_buf + insert_at, extras[use_extra].data, extra_len);<br><br>            &#125;<br><br>            <span class="hljs-comment">/* Tail */</span><br>            <span class="hljs-built_in">memcpy</span>(new_buf + insert_at + extra_len, out_buf + insert_at,<br>                   temp_len - insert_at);<br><br>            ck_free(out_buf);<br>            out_buf   = new_buf;<br>            temp_len += extra_len;<br><br>            <span class="hljs-keyword">break</span>;<br><br>          &#125;<br><br>      &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (common_fuzz_stuff(argv, out_buf, temp_len))<br>      <span class="hljs-keyword">goto</span> abandon_entry;<br><br>    <span class="hljs-comment">/* out_buf might have been mangled a bit, so let&#x27;s restore it to its</span><br><span class="hljs-comment">       original size and shape. */</span><br><br>    <span class="hljs-keyword">if</span> (temp_len &lt; len) out_buf = ck_realloc(out_buf, len);<br>    temp_len = len;<br>    <span class="hljs-built_in">memcpy</span>(out_buf, in_buf, len);       <span class="hljs-comment">// 恢复out_buf</span><br><br>    <span class="hljs-comment">/* If we&#x27;re finding new stuff, let&#x27;s run for a bit longer, limits</span><br><span class="hljs-comment">       permitting. */</span><br><br>    <span class="hljs-keyword">if</span> (queued_paths != havoc_queued) &#123; <span class="hljs-comment">// 发现了新路径</span><br><br>      <span class="hljs-keyword">if</span> (perf_score &lt;= HAVOC_MAX_MULT * <span class="hljs-number">100</span>) &#123;<br>        stage_max  *= <span class="hljs-number">2</span>;<br>        perf_score *= <span class="hljs-number">2</span>;<br>      &#125;<br><br>      havoc_queued = queued_paths;<br><br>    &#125;<br><br>  &#125;<br><br>  new_hit_cnt = queued_paths + unique_crashes;<br><br>  <span class="hljs-keyword">if</span> (!splice_cycle) &#123;  <span class="hljs-comment">// HAVOC</span><br>    stage_finds[STAGE_HAVOC]  += new_hit_cnt - orig_hit_cnt;<br>    stage_cycles[STAGE_HAVOC] += stage_max;<br>  &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// SPLICE</span><br>    stage_finds[STAGE_SPLICE]  += new_hit_cnt - orig_hit_cnt;<br>    stage_cycles[STAGE_SPLICE] += stage_max;<br>  &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> IGNORE_FINDS</span><br></code></pre></td></tr></table></figure>



<h4 id="SPLICING"><a href="#SPLICING" class="headerlink" title="SPLICING"></a>SPLICING</h4><p>拼接测试用例，重新进行Random Havoc。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-comment">/************</span><br><span class="hljs-comment">   * SPLICING *         // spling</span><br><span class="hljs-comment">   ************/</span><br><br>  <span class="hljs-comment">/* This is a last-resort strategy triggered by a full round with no findings.</span><br><span class="hljs-comment">     It takes the current input file, randomly selects another input, and</span><br><span class="hljs-comment">     splices them together at some offset, then relies on the havoc</span><br><span class="hljs-comment">     code to mutate that blob. */</span><br><br>retry_splicing:         <span class="hljs-comment">// 拼接测试用例，重新Random Havoc</span><br><br>  <span class="hljs-keyword">if</span> (use_splicing &amp;&amp; splice_cycle++ &lt; SPLICE_CYCLES &amp;&amp;<br>      queued_paths &gt; <span class="hljs-number">1</span> &amp;&amp; queue_cur-&gt;len &gt; <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 若</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">queue_entry</span>* <span class="hljs-title">target</span>;</span><br>    u32 tid, split_at;<br>    u8* new_buf;<br>    s32 f_diff, l_diff;<br><br>    <span class="hljs-comment">/* First of all, if we&#x27;ve modified in_buf for havoc, let&#x27;s clean that</span><br><span class="hljs-comment">       up... */</span><br><br>    <span class="hljs-keyword">if</span> (in_buf != orig_in) &#123;    <span class="hljs-comment">// 恢复in_buf</span><br>      ck_free(in_buf);<br>      in_buf = orig_in;<br>      len = queue_cur-&gt;len;<br>    &#125;<br><br>    <span class="hljs-comment">/* Pick a random queue entry and seek to it. Don&#x27;t splice with yourself. */</span><br><br>    <span class="hljs-keyword">do</span> &#123; tid = UR(queued_paths); &#125; <span class="hljs-keyword">while</span> (tid == current_entry);        <span class="hljs-comment">// 随机挑选目标</span><br><br>    splicing_with = tid;<br>    target = <span class="hljs-built_in">queue</span>;<br><br>    <span class="hljs-keyword">while</span> (tid &gt;= <span class="hljs-number">100</span>) &#123; target = target-&gt;next_100; tid -= <span class="hljs-number">100</span>; &#125;       <span class="hljs-comment">// 纠正tid取值，选取合适的target</span><br>    <span class="hljs-keyword">while</span> (tid--) target = target-&gt;next;<br><br>    <span class="hljs-comment">/* Make sure that the target has a reasonable length. */</span><br><br>    <span class="hljs-keyword">while</span> (target &amp;&amp; (target-&gt;len &lt; <span class="hljs-number">2</span> || target == queue_cur)) &#123;        <span class="hljs-comment">// 选取合适的target</span><br>      target = target-&gt;next;<br>      splicing_with++;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!target) <span class="hljs-keyword">goto</span> retry_splicing;<br><br>    <span class="hljs-comment">/* Read the testcase into a new buffer. */</span><br><br>    fd = open(target-&gt;fname, O_RDONLY); <span class="hljs-comment">// 打开target-&gt;fname</span><br><br>    <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) PFATAL(<span class="hljs-string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, target-&gt;fname);<br><br>    new_buf = ck_alloc_nozero(target-&gt;len);     <span class="hljs-comment">// 为new_buf分配空间</span><br><br>    ck_read(fd, new_buf, target-&gt;len, target-&gt;fname);   <span class="hljs-comment">// 将文件内容读取到new_buf中</span><br><br>    close(fd);<br><br>    <span class="hljs-comment">/* Find a suitable splicing location, somewhere between the first and</span><br><span class="hljs-comment">       the last differing byte. Bail out if the difference is just a single</span><br><span class="hljs-comment">       byte or so. */</span><br><br>    locate_diffs(in_buf, new_buf, MIN(len, target-&gt;len), &amp;f_diff, &amp;l_diff);<br><br>    <span class="hljs-keyword">if</span> (f_diff &lt; <span class="hljs-number">0</span> || l_diff &lt; <span class="hljs-number">2</span> || f_diff == l_diff) &#123; <span class="hljs-comment">// 判断splice是否合法</span><br>      ck_free(new_buf);<br>      <span class="hljs-keyword">goto</span> retry_splicing;<br>    &#125;<br><br>    <span class="hljs-comment">/* Split somewhere between the first and last differing byte. */</span><br><br>    split_at = f_diff + UR(l_diff - f_diff);    <span class="hljs-comment">// 随机选取位置切割new_buf</span><br><br>    <span class="hljs-comment">/* Do the thing. */</span><br><br>    len = target-&gt;len;<br>    <span class="hljs-built_in">memcpy</span>(new_buf, in_buf, split_at);<br>    in_buf = new_buf;<br><br>    ck_free(out_buf);<br>    out_buf = ck_alloc_nozero(len);<br>    <span class="hljs-built_in">memcpy</span>(out_buf, in_buf, len);       <span class="hljs-comment">// 拼接out_buf和new_buf</span><br><br>    <span class="hljs-keyword">goto</span> havoc_stage;   <span class="hljs-comment">// 跳转到havoc_stage，进行havoc</span><br><br>  &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* !IGNORE_FINDS */</span></span><br><br></code></pre></td></tr></table></figure>



<h4 id="后期收尾阶段"><a href="#后期收尾阶段" class="headerlink" title="后期收尾阶段"></a>后期收尾阶段</h4><p>设置fuzz标志位，取消映射，释放缓冲区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c">  ret_val = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 设置ret_val为0</span><br><br>abandon_entry:<br><br>  splicing_with = <span class="hljs-number">-1</span>;<br><br>  <span class="hljs-comment">/* Update pending_not_fuzzed count if we made it through the calibration</span><br><span class="hljs-comment">     cycle and have not seen this entry before. */</span><br>  <br>  <span class="hljs-comment">// 若stop_soon为空，且cal_failed为空，was_fuzzed为空</span><br>  <span class="hljs-keyword">if</span> (!stop_soon &amp;&amp; !queue_cur-&gt;cal_failed &amp;&amp; !queue_cur-&gt;was_fuzzed) &#123;<br>    queue_cur-&gt;was_fuzzed = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 设置was_fuzzed为1，表示已经fuzz过</span><br>    pending_not_fuzzed--;       <span class="hljs-comment">// pending_noe_fuzzed - 1</span><br>    <span class="hljs-keyword">if</span> (queue_cur-&gt;favored) pending_favored--;  <span class="hljs-comment">// pending_favored - 1</span><br>  &#125;<br><br>  munmap(orig_in, queue_cur-&gt;len);      <span class="hljs-comment">// 取消文件映射</span><br><br>  <span class="hljs-keyword">if</span> (in_buf != orig_in) ck_free(in_buf);       <span class="hljs-comment">// 释放缓冲区</span><br>  ck_free(out_buf);<br>  ck_free(eff_map);<br><br>  <span class="hljs-keyword">return</span> ret_val;<br><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> FLIP_BIT</span><br><br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="trim-case"><a href="#trim-case" class="headerlink" title="trim_case"></a>trim_case</h3><p>对测试用例进行剪枝，找到最小的符合原来路径的输入。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Trim all new test cases to save cycles when doing deterministic checks. The</span><br><span class="hljs-comment">   trimmer uses power-of-two increments somewhere between 1/16 and 1/1024 of</span><br><span class="hljs-comment">   file size, to keep the stage short and sweet. */</span><br><br><span class="hljs-type">static</span> u8 <span class="hljs-title function_">trim_case</span><span class="hljs-params">(<span class="hljs-type">char</span>** argv, <span class="hljs-keyword">struct</span> queue_entry* q, u8* in_buf)</span> &#123;<br><br>  <span class="hljs-type">static</span> u8 tmp[<span class="hljs-number">64</span>];<br>  <span class="hljs-type">static</span> u8 clean_trace[MAP_SIZE];<br><br>  u8  needs_write = <span class="hljs-number">0</span>, fault = <span class="hljs-number">0</span>;<br>  u32 trim_exec = <span class="hljs-number">0</span>;<br>  u32 remove_len;<br>  u32 len_p2;<br><br>  <span class="hljs-comment">/* Although the trimmer will be less useful when variable behavior is</span><br><span class="hljs-comment">     detected, it will still work to some extent, so we don&#x27;t check for</span><br><span class="hljs-comment">     this. */</span><br><br>  <span class="hljs-keyword">if</span> (q-&gt;len &lt; <span class="hljs-number">5</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;     <span class="hljs-comment">// 若queue的长度小于5，直接返回</span><br><br>  stage_name = tmp;<br>  bytes_trim_in += q-&gt;len;      <span class="hljs-comment">// 保存trim的字节总数</span><br><br>  <span class="hljs-comment">/* Select initial chunk len, starting with large steps. */</span><br><br>  len_p2 = next_p2(q-&gt;len);     <span class="hljs-comment">// 查找q-&gt;len的下一个2的幂</span><br><br>  remove_len = MAX(len_p2 / TRIM_START_STEPS, TRIM_MIN_BYTES);  <span class="hljs-comment">// 取len_p2 / 16 或者4之间最大的作为初始步长</span><br><br>  <span class="hljs-comment">/* Continue until the number of steps gets too high or the stepover</span><br><span class="hljs-comment">     gets too small. */</span><br><br>  <span class="hljs-keyword">while</span> (remove_len &gt;= MAX(len_p2 / TRIM_END_STEPS, TRIM_MIN_BYTES)) &#123;  <span class="hljs-comment">// 若remove_len大于等于len_p2 / 1024或者4</span><br><br>    u32 remove_pos = remove_len;<br><br>    <span class="hljs-built_in">sprintf</span>(tmp, <span class="hljs-string">&quot;trim %s/%s&quot;</span>, DI(remove_len), DI(remove_len));<br><br>    stage_cur = <span class="hljs-number">0</span>;<br>    stage_max = q-&gt;len / remove_len;    <span class="hljs-comment">// 计算最多阶段数量</span><br><br>    <span class="hljs-keyword">while</span> (remove_pos &lt; q-&gt;len) &#123;       <span class="hljs-comment">// 每次循环remove_len步长，直到遍历整个文件</span><br><br>      u32 trim_avail = MIN(remove_len, q-&gt;len - remove_pos);<br>      u32 cksum;<br>      <span class="hljs-comment">// 从in_buf开始，写入remove_pos字节，然后跳过remove_pos + trim_avail字节，写入到out_file(.cur_input)中</span><br>      write_with_gap(in_buf, q-&gt;len, remove_pos, trim_avail);<br><br>      fault = run_target(argv, exec_tmout);     <span class="hljs-comment">// 执行目标程序</span><br>      trim_execs++;<br><br>      <span class="hljs-keyword">if</span> (stop_soon || fault == FAULT_ERROR) <span class="hljs-keyword">goto</span> abort_trimming;       <span class="hljs-comment">// 若stop_soon不为空，或者fault为错误，跳转到abort_trimming</span><br><br>      <span class="hljs-comment">/* Note that we don&#x27;t keep track of crashes or hangs here; maybe TODO? */</span><br><br>      cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);<br><br>      <span class="hljs-comment">/* If the deletion had no impact on the trace, make it permanent. This</span><br><span class="hljs-comment">         isn&#x27;t perfect for variable-path inputs, but we&#x27;re just making a</span><br><span class="hljs-comment">         best-effort pass, so it&#x27;s not a big deal if we end up with false</span><br><span class="hljs-comment">         negatives every now and then. */</span><br><br>      <span class="hljs-keyword">if</span> (cksum == q-&gt;exec_cksum) &#123;     <span class="hljs-comment">// 判断cksum与q-&gt;exec_cksum，即判断是否产生了新的路径</span><br>                                        <span class="hljs-comment">// 若没有产生新的路径，进行剪枝操作</span><br><br>        u32 move_tail = q-&gt;len - remove_pos - trim_avail;<br><br>        q-&gt;len -= trim_avail;   <span class="hljs-comment">// 从q-&gt;len中减去trim_avail</span><br>        len_p2  = next_p2(q-&gt;len);      <span class="hljs-comment">//  继续找q-&gt;len的下一个2的幂</span><br><br>        memmove(in_buf + remove_pos, in_buf + remove_pos + trim_avail, <br>                move_tail);     <span class="hljs-comment">// 从in_buf[remove_pos]开始，删除trim_avail个字节</span><br><br>        <span class="hljs-comment">/* Let&#x27;s save a clean trace, which will be needed by</span><br><span class="hljs-comment">           update_bitmap_score once we&#x27;re done with the trimming stuff. */</span><br><br>        <span class="hljs-keyword">if</span> (!needs_write) &#123;     <span class="hljs-comment">// 若needs_write为空，设置needs_write为1</span><br><br>          needs_write = <span class="hljs-number">1</span>;<br>          <span class="hljs-built_in">memcpy</span>(clean_trace, trace_bits, MAP_SIZE);    <span class="hljs-comment">// 保存当前trace_bits到clean_trace中，便于后续恢复</span><br><br>        &#125;<br><br>      &#125; <span class="hljs-keyword">else</span> remove_pos += remove_len;<br><br>      <span class="hljs-comment">/* Since this can be slow, update the screen every now and then. */</span><br><br>      <span class="hljs-keyword">if</span> (!(trim_exec++ % stats_update_freq)) show_stats();     <span class="hljs-comment">// 若达到了stats_update_freq的倍数，显示stat</span><br>      stage_cur++;<br><br>    &#125;<br><br>    remove_len &gt;&gt;= <span class="hljs-number">1</span>;   <span class="hljs-comment">// remove_len / 2</span><br><br>  &#125;<br><br>  <span class="hljs-comment">/* If we have made changes to in_buf, we also need to update the on-disk</span><br><span class="hljs-comment">     version of the test case. */</span><br><br>  <span class="hljs-keyword">if</span> (needs_write) &#123;    <span class="hljs-comment">// 若needs_write不为空</span><br><br>    s32 fd;<br><br>    unlink(q-&gt;fname); <span class="hljs-comment">/* ignore errors */</span><br><br>    fd = open(q-&gt;fname, O_WRONLY | O_CREAT | O_EXCL, <span class="hljs-number">0600</span>);     <span class="hljs-comment">// 以只写模式打开q-&gt;fname</span><br><br>    <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) PFATAL(<span class="hljs-string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, q-&gt;fname);<br><br>    ck_write(fd, in_buf, q-&gt;len, q-&gt;fname);     <span class="hljs-comment">// 将in_buf写入fname文件中</span><br>    close(fd);<br><br>    <span class="hljs-built_in">memcpy</span>(trace_bits, clean_trace, MAP_SIZE);  <span class="hljs-comment">// 恢复trace_bits的值</span><br>    update_bitmap_score(q);<br><br>  &#125;<br><br>abort_trimming:<br><br>  bytes_trim_out += q-&gt;len;<br>  <span class="hljs-keyword">return</span> fault;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="calculate-score"><a href="#calculate-score" class="headerlink" title="calculate_score"></a>calculate_score</h3><p>根据queue entry的执行速度、覆盖到的path数和路径深度来评估出一个得分，这个得分perf_score在后面havoc的时候使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Calculate case desirability score to adjust the length of havoc fuzzing.</span><br><span class="hljs-comment">   A helper function for fuzz_one(). Maybe some of these constants should</span><br><span class="hljs-comment">   go into config.h. */</span><br><br><span class="hljs-type">static</span> u32 <span class="hljs-title function_">calculate_score</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> queue_entry* q)</span> &#123;<br><br>  u32 avg_exec_us = total_cal_us / total_cal_cycles;    <span class="hljs-comment">// 计算每轮平均执行时间</span><br>  u32 avg_bitmap_size = total_bitmap_size / total_bitmap_entries;       <span class="hljs-comment">// 计算每轮平均bitmap带线啊哦</span><br>  u32 perf_score = <span class="hljs-number">100</span>; <span class="hljs-comment">// 设置初始值perf_score为100</span><br><br>  <span class="hljs-comment">/* Adjust score based on execution speed of this path, compared to the</span><br><span class="hljs-comment">     global average. Multiplier ranges from 0.1x to 3x. Fast inputs are</span><br><span class="hljs-comment">     less expensive to fuzz, so we&#x27;re giving them more air time. */</span><br>  <br>  <span class="hljs-comment">// 根据执行时间与avg_exec_us的大小，更新perf_score</span><br>  <span class="hljs-keyword">if</span> (q-&gt;exec_us * <span class="hljs-number">0.1</span> &gt; avg_exec_us) perf_score = <span class="hljs-number">10</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (q-&gt;exec_us * <span class="hljs-number">0.25</span> &gt; avg_exec_us) perf_score = <span class="hljs-number">25</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (q-&gt;exec_us * <span class="hljs-number">0.5</span> &gt; avg_exec_us) perf_score = <span class="hljs-number">50</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (q-&gt;exec_us * <span class="hljs-number">0.75</span> &gt; avg_exec_us) perf_score = <span class="hljs-number">75</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (q-&gt;exec_us * <span class="hljs-number">4</span> &lt; avg_exec_us) perf_score = <span class="hljs-number">300</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (q-&gt;exec_us * <span class="hljs-number">3</span> &lt; avg_exec_us) perf_score = <span class="hljs-number">200</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (q-&gt;exec_us * <span class="hljs-number">2</span> &lt; avg_exec_us) perf_score = <span class="hljs-number">150</span>;<br><br>  <span class="hljs-comment">/* Adjust score based on bitmap size. The working theory is that better</span><br><span class="hljs-comment">     coverage translates to better targets. Multiplier from 0.25x to 3x. */</span><br>  <br>  <span class="hljs-comment">// 根据当前queue的bitmap_size与avg_bitmap_size的大小，更新perf_score</span><br>  <span class="hljs-keyword">if</span> (q-&gt;bitmap_size * <span class="hljs-number">0.3</span> &gt; avg_bitmap_size) perf_score *= <span class="hljs-number">3</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (q-&gt;bitmap_size * <span class="hljs-number">0.5</span> &gt; avg_bitmap_size) perf_score *= <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (q-&gt;bitmap_size * <span class="hljs-number">0.75</span> &gt; avg_bitmap_size) perf_score *= <span class="hljs-number">1.5</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (q-&gt;bitmap_size * <span class="hljs-number">3</span> &lt; avg_bitmap_size) perf_score *= <span class="hljs-number">0.25</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (q-&gt;bitmap_size * <span class="hljs-number">2</span> &lt; avg_bitmap_size) perf_score *= <span class="hljs-number">0.5</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (q-&gt;bitmap_size * <span class="hljs-number">1.5</span> &lt; avg_bitmap_size) perf_score *= <span class="hljs-number">0.75</span>;<br><br>  <span class="hljs-comment">/* Adjust score based on handicap. Handicap is proportional to how late</span><br><span class="hljs-comment">     in the game we learned about this path. Latecomers are allowed to run</span><br><span class="hljs-comment">     for a bit longer until they catch up with the rest. */</span><br><br>  <span class="hljs-keyword">if</span> (q-&gt;handicap &gt;= <span class="hljs-number">4</span>) &#123;<br><br>    perf_score *= <span class="hljs-number">4</span>;<br>    q-&gt;handicap -= <span class="hljs-number">4</span>;<br><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (q-&gt;handicap) &#123;<br><br>    perf_score *= <span class="hljs-number">2</span>;<br>    q-&gt;handicap--;<br><br>  &#125;<br><br>  <span class="hljs-comment">/* Final adjustment based on input depth, under the assumption that fuzzing</span><br><span class="hljs-comment">     deeper test cases is more likely to reveal stuff that can&#x27;t be</span><br><span class="hljs-comment">     discovered with traditional fuzzers. */</span><br>  <br>  <span class="hljs-comment">// 根据当前q-depth落入的区间，更新perf_score</span><br>  <span class="hljs-keyword">switch</span> (q-&gt;depth) &#123;<br><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span> ... <span class="hljs-number">3</span>:   <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span> ... <span class="hljs-number">7</span>:   perf_score *= <span class="hljs-number">2</span>; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">8</span> ... <span class="hljs-number">13</span>:  perf_score *= <span class="hljs-number">3</span>; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">14</span> ... <span class="hljs-number">25</span>: perf_score *= <span class="hljs-number">4</span>; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:        perf_score *= <span class="hljs-number">5</span>;<br><br>  &#125;<br><br>  <span class="hljs-comment">/* Make sure that we don&#x27;t go over limit. */</span><br><br>  <span class="hljs-keyword">if</span> (perf_score &gt; HAVOC_MAX_MULT * <span class="hljs-number">100</span>) perf_score = HAVOC_MAX_MULT * <span class="hljs-number">100</span>;<br><br>  <span class="hljs-keyword">return</span> perf_score;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="common-fuzz-stuff"><a href="#common-fuzz-stuff" class="headerlink" title="common_fuzz_stuff"></a>common_fuzz_stuff</h3><p>修改测试用例，执行target程序，处理结果。处理成功返回0，否则返回1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Write a modified test case, run program, process results. Handle</span><br><span class="hljs-comment">   error conditions, returning 1 if it&#x27;s time to bail out. This is</span><br><span class="hljs-comment">   a helper function for fuzz_one(). */</span><br><br>EXP_ST u8 <span class="hljs-title function_">common_fuzz_stuff</span><span class="hljs-params">(<span class="hljs-type">char</span>** argv, u8* out_buf, u32 len)</span> &#123;<br><br>  u8 fault;<br>  <br>  <span class="hljs-comment">// static u8* (*post_handler)(u8* buf, u32* len);</span><br>  <span class="hljs-keyword">if</span> (post_handler) &#123;   <span class="hljs-comment">// 若post_handler不为空</span><br><br>    out_buf = post_handler(out_buf, &amp;len);      <span class="hljs-comment">// 调用post_handler，即afl_postprocess处理out_buf</span><br>    <span class="hljs-keyword">if</span> (!out_buf || !len) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;     <span class="hljs-comment">// 若out_buf为空，或者len等于0，直接返回</span><br><br>  &#125;<br><br>  write_to_testcase(out_buf, len);      <span class="hljs-comment">// 将out_buf写入out_file</span><br><br>  fault = run_target(argv, exec_tmout); <span class="hljs-comment">// 执行目标程序</span><br><br>  <span class="hljs-keyword">if</span> (stop_soon) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">if</span> (fault == FAULT_TMOUT) &#123;   <span class="hljs-comment">// 若fault等于FAULT_TMOUT，即出现了超时错误</span><br><br>    <span class="hljs-keyword">if</span> (subseq_tmouts++ &gt; TMOUT_LIMIT) &#123;        <span class="hljs-comment">// subseq_tmouts + 1</span><br>      cur_skipped_paths++;      <span class="hljs-comment">// cur_skipped_paths + 1</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>  &#125; <span class="hljs-keyword">else</span> subseq_tmouts = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">/* Users can hit us with SIGUSR1 to request the current input</span><br><span class="hljs-comment">     to be abandoned. */</span><br><br>  <span class="hljs-keyword">if</span> (skip_requested) &#123; <span class="hljs-comment">// 若skip_requested不为空，即当前输入被抛弃</span><br><br>     skip_requested = <span class="hljs-number">0</span>;<br>     cur_skipped_paths++;<br>     <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>  &#125;<br><br>  <span class="hljs-comment">/* This handles FAULT_ERROR for us: */</span><br><br>  queued_discovered += save_if_interesting(argv, out_buf, len, fault);  <span class="hljs-comment">// 发现了新路径，queued_discovered + 1</span><br><br>  <span class="hljs-keyword">if</span> (!(stage_cur % stats_update_freq) || stage_cur + <span class="hljs-number">1</span> == stage_max)<br>    show_stats();       <span class="hljs-comment">// 若stage_cur是stats_update_freq的整数倍或是执行到最后一轮，展示stats</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="save-if-interesting"><a href="#save-if-interesting" class="headerlink" title="save_if_interesting"></a>save_if_interesting</h3><p>判断case是否为interesting模式。若是crash，则保存case到queue文件夹以及crash文件夹中，设置keeping为1，返回1；若是tmout，保存到hangs文件夹中，返回0。其它情况也返回0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Check if the result of an execve() during routine fuzzing is interesting,</span><br><span class="hljs-comment">   save or queue the input test case for further analysis if so. Returns 1 if</span><br><span class="hljs-comment">   entry is saved, 0 otherwise. */</span><br><br><span class="hljs-type">static</span> u8 <span class="hljs-title function_">save_if_interesting</span><span class="hljs-params">(<span class="hljs-type">char</span>** argv, <span class="hljs-type">void</span>* mem, u32 len, u8 fault)</span> &#123;<br><br>  u8  *fn = <span class="hljs-string">&quot;&quot;</span>;<br>  u8  hnb;<br>  s32 fd;<br>  u8  keeping = <span class="hljs-number">0</span>, res;<br><br>  <span class="hljs-keyword">if</span> (fault == crash_mode) &#123;    <span class="hljs-comment">// 若fault为crash_mode</span><br><br>    <span class="hljs-comment">/* Keep only if there are new bits in the map, add to queue for</span><br><span class="hljs-comment">       future fuzzing, etc. */</span><br><br>    <span class="hljs-keyword">if</span> (!(hnb = has_new_bits(virgin_bits))) &#123;   <span class="hljs-comment">// 判断是否发现了新的路径或者path的命中率增加</span><br>      <span class="hljs-keyword">if</span> (crash_mode) total_crashes++;          <span class="hljs-comment">// 若crash_mode不为空，total_crashed + 1</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;    <br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SIMPLE_FILES</span><br><br>    fn = alloc_printf(<span class="hljs-string">&quot;%s/queue/id:%06u,%s&quot;</span>, out_dir, queued_paths,<br>                      describe_op(hnb));        <span class="hljs-comment">// fn = out_dir/queue/id:</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><br>    fn = alloc_printf(<span class="hljs-string">&quot;%s/queue/id_%06u&quot;</span>, out_dir, queued_paths);<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* ^!SIMPLE_FILES */</span></span><br><br>    add_to_queue(fn, len, <span class="hljs-number">0</span>);   <span class="hljs-comment">// 将fn添加到队列中</span><br><br>    <span class="hljs-keyword">if</span> (hnb == <span class="hljs-number">2</span>) &#123;     <span class="hljs-comment">// 发现了新路径</span><br>      queue_top-&gt;has_new_cov = <span class="hljs-number">1</span>;<br>      queued_with_cov++;<br>    &#125;<br><br>    queue_top-&gt;exec_cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);   <span class="hljs-comment">// 计算trace_bits校验和</span><br><br>    <span class="hljs-comment">/* Try to calibrate inline; this also calls update_bitmap_score() when</span><br><span class="hljs-comment">       successful. */</span><br><br>    res = calibrate_case(argv, queue_top, mem, queue_cycle - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);     <span class="hljs-comment">// 对新添加的路径进行评测</span><br><br>    <span class="hljs-keyword">if</span> (res == FAULT_ERROR)     <span class="hljs-comment">// 若res返回值为FAULT_ERROR，报错并退出</span><br>      FATAL(<span class="hljs-string">&quot;Unable to execute target application&quot;</span>);<br><br>    fd = open(fn, O_WRONLY | O_CREAT | O_EXCL, <span class="hljs-number">0600</span>);   <span class="hljs-comment">// 以只写方式打开fn文件</span><br>    <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) PFATAL(<span class="hljs-string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, fn);<br>    ck_write(fd, mem, len, fn); <span class="hljs-comment">// 将mem写入文件</span><br>    close(fd);<br><br>    keeping = <span class="hljs-number">1</span>;<br><br>  &#125;<br><br>  <span class="hljs-keyword">switch</span> (fault) &#123;      <span class="hljs-comment">// 判断报错类型</span><br><br>    <span class="hljs-keyword">case</span> FAULT_TMOUT:   <span class="hljs-comment">// FAULT_TMOUT</span><br><br>      <span class="hljs-comment">/* Timeouts are not very interesting, but we&#x27;re still obliged to keep</span><br><span class="hljs-comment">         a handful of samples. We use the presence of new bits in the</span><br><span class="hljs-comment">         hang-specific bitmap as a signal of uniqueness. In &quot;dumb&quot; mode, we</span><br><span class="hljs-comment">         just keep everything. */</span><br><br>      total_tmouts++;<br><br>      <span class="hljs-keyword">if</span> (unique_hangs &gt;= KEEP_UNIQUE_HANG) <span class="hljs-keyword">return</span> keeping;     <span class="hljs-comment">// 若unique_hangs &gt;= 500，返回keeping</span><br><br>      <span class="hljs-keyword">if</span> (!dumb_mode) &#123; <span class="hljs-comment">// 若不是简易模式</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> WORD_SIZE_64</span><br>        simplify_trace((u64*)trace_bits);       <span class="hljs-comment">// 简化路径</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        simplify_trace((u32*)trace_bits);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* ^WORD_SIZE_64 */</span></span><br><br>        <span class="hljs-keyword">if</span> (!has_new_bits(virgin_tmout)) <span class="hljs-keyword">return</span> keeping;        <span class="hljs-comment">// 若没有发现新的超时路径，返回kepping</span><br><br>      &#125;<br><br>      unique_tmouts++;  <span class="hljs-comment">// unique_tmounts + 1</span><br><br>      <span class="hljs-comment">/* Before saving, we make sure that it&#x27;s a genuine hang by re-running</span><br><span class="hljs-comment">         the target with a more generous timeout (unless the default timeout</span><br><span class="hljs-comment">         is already generous). */</span><br><br>      <span class="hljs-keyword">if</span> (exec_tmout &lt; hang_tmout) &#123;    <span class="hljs-comment">// 若exec_tmout &lt; hang_tmout，</span><br><br>        u8 new_fault;<br>        write_to_testcase(mem, len);    <span class="hljs-comment">// 将mem写入out_file(.cur_input)中</span><br>        new_fault = run_target(argv, hang_tmout);       <span class="hljs-comment">// 重新执行目标程序</span><br><br>        <span class="hljs-comment">/* A corner case that one user reported bumping into: increasing the</span><br><span class="hljs-comment">           timeout actually uncovers a crash. Make sure we don&#x27;t discard it if</span><br><span class="hljs-comment">           so. */</span><br><br>        <span class="hljs-keyword">if</span> (!stop_soon &amp;&amp; new_fault == FAULT_CRASH) <span class="hljs-keyword">goto</span> keep_as_crash; <span class="hljs-comment">// 若FAULT是FAULT_CRASH，跳转到keep_as_crash</span><br><br>        <span class="hljs-keyword">if</span> (stop_soon || new_fault != FAULT_TMOUT) <span class="hljs-keyword">return</span> keeping;<br><br>      &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SIMPLE_FILES</span><br><br>      fn = alloc_printf(<span class="hljs-string">&quot;%s/hangs/id:%06llu,%s&quot;</span>, out_dir,<br>                        unique_hangs, describe_op(<span class="hljs-number">0</span>));<br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><br>      fn = alloc_printf(<span class="hljs-string">&quot;%s/hangs/id_%06llu&quot;</span>, out_dir,<br>                        unique_hangs);<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* ^!SIMPLE_FILES */</span></span><br><br>      unique_hangs++;   <span class="hljs-comment">// unique_hangs + 1</span><br><br>      last_hang_time = get_cur_time();<br><br>      <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-keyword">case</span> FAULT_CRASH:   <span class="hljs-comment">// FAULT_CRASH</span><br><br>keep_as_crash:<br><br>      <span class="hljs-comment">/* This is handled in a manner roughly similar to timeouts,</span><br><span class="hljs-comment">         except for slightly different limits and no need to re-run test</span><br><span class="hljs-comment">         cases. */</span><br><br>      total_crashes++;  <span class="hljs-comment">// 总crashes + 1</span><br><br>      <span class="hljs-keyword">if</span> (unique_crashes &gt;= KEEP_UNIQUE_CRASH) <span class="hljs-keyword">return</span> keeping;<br><br>      <span class="hljs-keyword">if</span> (!dumb_mode) &#123; <span class="hljs-comment">// 若不是dumb_mode</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> WORD_SIZE_64</span><br>        simplify_trace((u64*)trace_bits);       <span class="hljs-comment">// 简化路径</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        simplify_trace((u32*)trace_bits);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* ^WORD_SIZE_64 */</span></span><br><br>        <span class="hljs-keyword">if</span> (!has_new_bits(virgin_crash)) <span class="hljs-keyword">return</span> keeping;        <span class="hljs-comment">// 判断是否发现新的crash</span><br><br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (!unique_crashes) write_crash_readme();        <span class="hljs-comment">// 创建readme文件</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SIMPLE_FILES</span><br><br>      fn = alloc_printf(<span class="hljs-string">&quot;%s/crashes/id:%06llu,sig:%02u,%s&quot;</span>, out_dir,<br>                        unique_crashes, kill_signal, describe_op(<span class="hljs-number">0</span>));<br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><br>      fn = alloc_printf(<span class="hljs-string">&quot;%s/crashes/id_%06llu_%02u&quot;</span>, out_dir, unique_crashes,<br>                        kill_signal);<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* ^!SIMPLE_FILES */</span></span><br><br>      unique_crashes++; <span class="hljs-comment">// unique_crashes + 1</span><br><br>      last_crash_time = get_cur_time();<br>      last_crash_execs = total_execs;<br><br>      <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-keyword">case</span> FAULT_ERROR: FATAL(<span class="hljs-string">&quot;Unable to execute target application&quot;</span>);<br><br>    <span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span> keeping;<br><br>  &#125;<br><br>  <span class="hljs-comment">/* If we&#x27;re here, we apparently want to save the crash or hang</span><br><span class="hljs-comment">     test case, too. */</span><br><br>  fd = open(fn, O_WRONLY | O_CREAT | O_EXCL, <span class="hljs-number">0600</span>);     <span class="hljs-comment">// 打开fn文件</span><br>  <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) PFATAL(<span class="hljs-string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, fn);<br>  ck_write(fd, mem, len, fn);   <span class="hljs-comment">// 保存mem到fn文件</span><br>  close(fd);<br><br>  ck_free(fn);<br><br>  <span class="hljs-keyword">return</span> keeping;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="simplify-trace"><a href="#simplify-trace" class="headerlink" title="simplify_trace"></a>simplify_trace</h3><p>简化路径信息，将命中路径设置为0x80，未命中的设置为1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Destructively simplify trace by eliminating hit count information</span><br><span class="hljs-comment">   and replacing it with 0x80 or 0x01 depending on whether the tuple</span><br><span class="hljs-comment">   is hit or not. Called on every new crash or timeout, should be</span><br><span class="hljs-comment">   reasonably fast. */</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> u8 simplify_lookup[<span class="hljs-number">256</span>] = &#123; <br><br>  [<span class="hljs-number">0</span>]         = <span class="hljs-number">1</span>,<br>  [<span class="hljs-number">1</span> ... <span class="hljs-number">255</span>] = <span class="hljs-number">128</span><br><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> WORD_SIZE_64</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">simplify_trace</span><span class="hljs-params">(u64* mem)</span> &#123;<br><br>  u32 i = MAP_SIZE &gt;&gt; <span class="hljs-number">3</span>;<br><br>  <span class="hljs-keyword">while</span> (i--) &#123;<br><br>    <span class="hljs-comment">/* Optimize for sparse bitmaps. */</span><br><br>    <span class="hljs-keyword">if</span> (unlikely(*mem)) &#123;<br><br>      u8* mem8 = (u8*)mem;<br><br>      mem8[<span class="hljs-number">0</span>] = simplify_lookup[mem8[<span class="hljs-number">0</span>]];<br>      mem8[<span class="hljs-number">1</span>] = simplify_lookup[mem8[<span class="hljs-number">1</span>]];<br>      mem8[<span class="hljs-number">2</span>] = simplify_lookup[mem8[<span class="hljs-number">2</span>]];<br>      mem8[<span class="hljs-number">3</span>] = simplify_lookup[mem8[<span class="hljs-number">3</span>]];<br>      mem8[<span class="hljs-number">4</span>] = simplify_lookup[mem8[<span class="hljs-number">4</span>]];<br>      mem8[<span class="hljs-number">5</span>] = simplify_lookup[mem8[<span class="hljs-number">5</span>]];<br>      mem8[<span class="hljs-number">6</span>] = simplify_lookup[mem8[<span class="hljs-number">6</span>]];<br>      mem8[<span class="hljs-number">7</span>] = simplify_lookup[mem8[<span class="hljs-number">7</span>]];<br><br>    &#125; <span class="hljs-keyword">else</span> *mem = <span class="hljs-number">0x0101010101010101</span>ULL;<br><br>    mem++;<br><br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>





<p><strong>参考链接</strong></p>
<p><a target="_blank" rel="noopener" href="https://eternalsakura13.com/2020/08/23/afl/">https://eternalsakura13.com/2020/08/23/afl/</a></p>
<p><a target="_blank" rel="noopener" href="https://hollk.blog.csdn.net/category_11470526.html">https://hollk.blog.csdn.net/category_11470526.html</a></p>
<p><a target="_blank" rel="noopener" href="https://paper.seebug.org/1732/">https://paper.seebug.org/1732/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.z1r0.top/2023/03/23/AFL-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">https://www.z1r0.top/2023/03/23/AFL-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/fuzz/" class="category-chain-item">fuzz</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/fuzz/">#fuzz</a>
      
        <a href="/tags/afl/">#afl</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>AFL源码分析(四)</div>
      <div>http://example.com/2023/10/04/AFL源码分析四/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>l1s00t</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年10月4日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2023年10月6日</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/10/16/afl-challenges/" title="afl-challenges">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">afl-challenges</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/10/04/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%89/" title="AFL源码分析(三)">
                        <span class="hidden-mobile">AFL源码分析(三)</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      

    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
